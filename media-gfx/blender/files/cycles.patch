diff --git a/intern/cycles/blender/addon/properties.py b/intern/cycles/blender/addon/properties.py
index a86f162..4c04c67 100644
--- a/intern/cycles/blender/addon/properties.py
+++ b/intern/cycles/blender/addon/properties.py
@@ -90,6 +90,7 @@ enum_tile_order = (
     ('LEFT_TO_RIGHT', "Left to Right", "Render from left to right"),
     ('TOP_TO_BOTTOM', "Top to Bottom", "Render from top to bottom"),
     ('BOTTOM_TO_TOP', "Bottom to Top", "Render from bottom to top"),
+    ('HILBERT', "Hilbert Curve", "Render along a hilbert curve"),
     )
 
 enum_use_layer_samples = (
@@ -504,6 +505,32 @@ class CyclesRenderSettings(bpy.types.PropertyGroup):
                 ),
             )
 
+        cls.adaptive_distribution = BoolProperty(
+            name="Adaptive distribution",
+            default=False,
+            description="Distribute samples inside every tile according to the remaining error, "
+                        "mainly useful for bigger tiles (this doesn't affect the total samples per tile)",
+            )
+        cls.adaptive_stopping = BoolProperty(
+            name="Adaptive stopping",
+            default=False,
+            description="Stop rendering a tile once its error falls below the threshold "
+                        "(note that tiles still stop when the sample count is reached).",
+            )
+        cls.adaptive_confidence = FloatProperty(
+            name="Confidence",
+            min=0, max=100,
+            default=80,
+            description="Desired confidence (in percent) that the remaining error in the tile is not visible anymore. "
+                        "The bigger this value is, the longer rendering will take.",
+            )
+        cls.adaptive_map_interval = IntProperty(
+            name="Map update rate",
+            min=1, max=2147483647,
+            default=25,
+            description="Number of samples taken before the error is re-estimated",
+            )
+
     @classmethod
     def unregister(cls):
         del bpy.types.Scene.cycles
@@ -693,6 +720,12 @@ class CyclesLampSettings(bpy.types.PropertyGroup):
                             "reduces noise for area lamps and sharp glossy materials",
                 default=False,
                 )
+        cls.is_portal = BoolProperty(
+                name="Is Portal",
+                description="Uses this area lamp to guide sampling of the background, "
+                            "note that this will make the lamp invisible",
+                default=False,
+                )
 
     @classmethod
     def unregister(cls):
diff --git a/intern/cycles/blender/addon/ui.py b/intern/cycles/blender/addon/ui.py
index 63518d7..644e341 100644
--- a/intern/cycles/blender/addon/ui.py
+++ b/intern/cycles/blender/addon/ui.py
@@ -155,7 +155,9 @@ class CyclesRender_PT_sampling(CyclesButtonsPanel, Panel):
             sub.prop(cscene, "volume_samples", text="Volume")
 
         if use_cpu(context) or cscene.feature_set == 'EXPERIMENTAL':
-            layout.row().prop(cscene, "sampling_pattern", text="Pattern")
+            sub = layout.row()
+            sub.enabled = not (cscene.adaptive_stopping and cscene.feature_set == 'EXPERIMENTAL')
+            sub.prop(cscene, "sampling_pattern", text="Pattern")
 
         for rl in scene.render.layers:
             if rl.samples > 0:
@@ -246,6 +248,28 @@ class CyclesRender_PT_motion_blur(CyclesButtonsPanel, Panel):
         row = layout.row()
         row.prop(rd, "motion_blur_shutter")
 
+class CyclesRender_PT_adaptive_sampling(CyclesButtonsPanel, Panel):
+    bl_label = "Adaptive Sampling"
+    bl_options = {'DEFAULT_CLOSED'}
+
+    @classmethod
+    def poll(cls, context):
+        return context.scene.cycles.feature_set == 'EXPERIMENTAL'
+
+    def draw_header(self, context):
+        cscene = context.scene.cycles
+        self.layout.prop(cscene, "adaptive_stopping", text="")
+
+    def draw(self, context):
+        layout = self.layout
+
+        cscene = context.scene.cycles
+        layout.active = cscene.adaptive_stopping
+
+        col = layout.column()
+        col.prop(cscene, "adaptive_distribution")
+        col.prop(cscene, "adaptive_confidence", slider=True)
+        col.prop(cscene, "adaptive_map_interval")
 
 class CyclesRender_PT_film(CyclesButtonsPanel, Panel):
     bl_label = "Film"
@@ -729,13 +753,21 @@ class CyclesLamp_PT_lamp(CyclesButtonsPanel, Panel):
                 sub.prop(lamp, "size", text="Size X")
                 sub.prop(lamp, "size_y", text="Size Y")
 
+        sub = col.column(align=True)
+        sub.active = not (lamp.type == 'AREA' and clamp.is_portal)
         if cscene.progressive == 'BRANCHED_PATH':
-            col.prop(clamp, "samples")
-        col.prop(clamp, "max_bounces")
+            sub.prop(clamp, "samples")
+        sub.prop(clamp, "max_bounces")
 
         col = split.column()
-        col.prop(clamp, "cast_shadow")
-        col.prop(clamp, "use_multiple_importance_sampling", text="Multiple Importance")
+
+        sub = col.column(align=True)
+        sub.active = not (lamp.type == 'AREA' and clamp.is_portal)
+        sub.prop(clamp, "cast_shadow")
+        sub.prop(clamp, "use_multiple_importance_sampling", text="Multiple Importance")
+
+        if lamp.type == 'AREA':
+            col.prop(clamp, "is_portal")
 
         if lamp.type == 'HEMI':
             layout.label(text="Not supported, interpreted as sun lamp")
@@ -747,7 +779,7 @@ class CyclesLamp_PT_nodes(CyclesButtonsPanel, Panel):
 
     @classmethod
     def poll(cls, context):
-        return context.lamp and CyclesButtonsPanel.poll(context)
+        return context.lamp and not (context.lamp.type == 'AREA' and context.lamp.cycles.is_portal) and CyclesButtonsPanel.poll(context)
 
     def draw(self, context):
         layout = self.layout
diff --git a/intern/cycles/blender/blender_object.cpp b/intern/cycles/blender/blender_object.cpp
index e827d46..abdec9d 100644
--- a/intern/cycles/blender/blender_object.cpp
+++ b/intern/cycles/blender/blender_object.cpp
@@ -171,6 +171,11 @@ void BlenderSync::sync_light(BL::Object b_parent, int persistent_id[OBJECT_PERSI
 
 	light->max_bounces = get_int(clamp, "max_bounces");
 
+	if(light->type == LIGHT_AREA)
+		light->portal = get_boolean(clamp, "is_portal");
+	else
+		light->portal = false;
+
 	/* visibility */
 	uint visibility = object_ray_visibility(b_ob);
 	light->use_diffuse = (visibility & PATH_RAY_DIFFUSE) != 0;
@@ -189,30 +194,28 @@ void BlenderSync::sync_background_light()
 	if(b_world) {
 		PointerRNA cscene = RNA_pointer_get(&b_scene.ptr, "cycles");
 		PointerRNA cworld = RNA_pointer_get(&b_world.ptr, "cycles");
-		bool sample_as_light = get_boolean(cworld, "sample_as_light");
-
-		if(sample_as_light) {
-			/* test if we need to sync */
-			Light *light;
-			ObjectKey key(b_world, 0, b_world);
-
-			if(light_map.sync(&light, b_world, b_world, key) ||
-			   world_recalc ||
-			   b_world.ptr.data != world_map)
-			{
-				light->type = LIGHT_BACKGROUND;
-				light->map_resolution  = get_int(cworld, "sample_map_resolution");
-				light->shader = scene->default_background;
+
+		/* test if we need to sync */
+		Light *light;
+		ObjectKey key(b_world, 0, b_world);
+
+		if(light_map.sync(&light, b_world, b_world, key) ||
+			world_recalc ||
+			b_world.ptr.data != world_map)
+		{
+			light->type = LIGHT_BACKGROUND;
+			light->map_resolution  = get_int(cworld, "sample_map_resolution");
+			light->shader = scene->default_background;
+			light->use_mis = get_boolean(cworld, "sample_as_light");
 				
-				int samples = get_int(cworld, "samples");
-				if(get_boolean(cscene, "use_square_samples"))
-					light->samples = samples * samples;
-				else
-					light->samples = samples;
-
-				light->tag_update(scene);
-				light_map.set_recalc(b_world);
-			}
+			int samples = get_int(cworld, "samples");
+			if(get_boolean(cscene, "use_square_samples"))
+				light->samples = samples * samples;
+			else
+				light->samples = samples;
+
+			light->tag_update(scene);
+			light_map.set_recalc(b_world);
 		}
 	}
 
diff --git a/intern/cycles/blender/blender_session.cpp b/intern/cycles/blender/blender_session.cpp
index e61203d..3e50563 100644
--- a/intern/cycles/blender/blender_session.cpp
+++ b/intern/cycles/blender/blender_session.cpp
@@ -136,7 +136,7 @@ void BlenderSession::create_session()
 	BufferParams buffer_params = BlenderSync::get_buffer_params(b_render, b_scene, b_v3d, b_rv3d, scene->camera, width, height);
 	session->reset(buffer_params, session_params.samples);
 
-	b_engine.use_highlight_tiles(session_params.progressive_refine == false);
+	b_engine.use_highlight_tiles(session_params.progressive_refine == false || session_params.error_progressive);
 }
 
 void BlenderSession::reset_session(BL::BlendData b_data_, BL::Scene b_scene_)
@@ -271,6 +271,12 @@ static PassType get_pass_type(BL::RenderPass b_pass)
 		{
 			if(b_pass.debug_type() == BL::RenderPass::debug_type_BVH_TRAVERSAL_STEPS)
 				return PASS_BVH_TRAVERSAL_STEPS;
+			if(b_pass.debug_type() == BL::RenderPass::debug_type_SAMPLES)
+				return PASS_SAMPLES;
+			if(b_pass.debug_type() == BL::RenderPass::debug_type_VARIANCE)
+				return PASS_VARIANCE;
+			if(b_pass.debug_type() == BL::RenderPass::debug_type_IMPORTANCE)
+				return PASS_IMPORTANCE;
 			break;
 		}
 #endif
@@ -341,7 +347,7 @@ static void end_render_result(BL::RenderEngine b_engine, BL::RenderResult b_rr,
 	b_engine.end_result(b_rr, (int)cancel, (int)do_merge_results);
 }
 
-void BlenderSession::do_write_update_render_tile(RenderTile& rtile, bool do_update_only)
+void BlenderSession::do_write_update_render_tile(RenderTile& rtile, bool do_update_only, bool remove_highlight)
 {
 	BufferParams& params = rtile.buffers->params;
 	int x = params.full_x - session->tile_manager.params.full_x;
@@ -377,18 +383,18 @@ void BlenderSession::do_write_update_render_tile(RenderTile& rtile, bool do_upda
 			update_render_result(b_rr, b_rlay, rtile);
 		}
 
-		end_render_result(b_engine, b_rr, true, true);
+		end_render_result(b_engine, b_rr, !remove_highlight, true);
 	}
 	else {
 		/* write result */
 		write_render_result(b_rr, b_rlay, rtile);
-		end_render_result(b_engine, b_rr, false, true);
+		end_render_result(b_engine, b_rr, !remove_highlight, true);
 	}
 }
 
 void BlenderSession::write_render_tile(RenderTile& rtile)
 {
-	do_write_update_render_tile(rtile, false);
+	do_write_update_render_tile(rtile, false, true);
 }
 
 void BlenderSession::update_render_tile(RenderTile& rtile)
@@ -397,10 +403,12 @@ void BlenderSession::update_render_tile(RenderTile& rtile)
 	 * be updated in blender side
 	 * would need to be investigated a bit further, but for now shall be fine
 	 */
-	if (!b_engine.is_preview())
-		do_write_update_render_tile(rtile, true);
+	if(!b_engine.is_preview()) {
+		bool remove_highlight = session->params.error_progressive && (rtile.sample == rtile.start_sample + rtile.num_samples);
+		do_write_update_render_tile(rtile, true, remove_highlight);
+	}
 	else
-		do_write_update_render_tile(rtile, false);
+		do_write_update_render_tile(rtile, false, false);
 }
 
 void BlenderSession::render()
@@ -436,9 +444,14 @@ void BlenderSession::render()
 		/* add passes */
 		vector<Pass> passes;
 		Pass::add(PASS_COMBINED, passes);
+		Pass::add(PASS_SHADOWCATCHER, passes);
 #ifdef WITH_CYCLES_DEBUG
 		Pass::add(PASS_BVH_TRAVERSAL_STEPS, passes);
 #endif
+		if(session_params.adaptive_stopping) {
+			Pass::add(PASS_SAMPLES, passes);
+			Pass::add(PASS_VARIANCE, passes);
+		}
 
 		if(session_params.device.advanced_shading) {
 
@@ -783,22 +796,42 @@ void BlenderSession::get_status(string& status, string& substatus)
 void BlenderSession::get_progress(float& progress, double& total_time, double& render_time)
 {
 	double tile_time;
-	int tile, sample, samples_per_tile;
+	int tile;
 	int tile_total = session->tile_manager.state.num_tiles;
 	int samples = session->tile_manager.state.sample + 1;
 	int total_samples = session->tile_manager.num_samples;
 
 	session->progress.get_tile(tile, total_time, render_time, tile_time);
 
-	sample = session->progress.get_sample();
-	samples_per_tile = session->tile_manager.num_samples;
+	if(session->params.error_progressive) {
+		if(tile > tile_total) {
+			float max_error = session->tile_manager.state.tiles.top().priority;
+			float convergence_speed = max_error * sqrtf(tile);
+			float convergence_factor = convergence_speed / session->params.stopping_threshold;
+			progress = ((float) tile / (convergence_factor*convergence_factor));
+		}
+		else
+			progress = 0.0f;
+	}
+	else if(session->params.adaptive_stopping) {
+		if(tile_total)
+			progress = (float)tile / (float)tile_total;
+		else
+			progress = 0.0f;
+	}
+	else {
+		int sample, samples_per_tile;
 
-	if(background && samples_per_tile && tile_total)
-		progress = ((float)sample / (float)(tile_total * samples_per_tile));
-	else if(!background && samples > 0 && total_samples != USHRT_MAX)
-		progress = ((float)samples) / total_samples;
-	else
-		progress = 0.0;
+		sample = session->progress.get_sample();
+		samples_per_tile = session->tile_manager.num_samples;
+
+		if(background && samples_per_tile && tile_total)
+			progress = ((float)sample / (float)(tile_total * samples_per_tile));
+		else if(!background && samples > 0 && total_samples != USHRT_MAX)
+			progress = ((float)samples) / total_samples;
+		else
+			progress = 0.0;
+	}
 }
 
 void BlenderSession::update_bake_progress()
diff --git a/intern/cycles/blender/blender_session.h b/intern/cycles/blender/blender_session.h
index c807028..8674aac 100644
--- a/intern/cycles/blender/blender_session.h
+++ b/intern/cycles/blender/blender_session.h
@@ -102,7 +102,7 @@ public:
 
 protected:
 	void do_write_update_render_result(BL::RenderResult b_rr, BL::RenderLayer b_rlay, RenderTile& rtile, bool do_update_only);
-	void do_write_update_render_tile(RenderTile& rtile, bool do_update_only);
+	void do_write_update_render_tile(RenderTile& rtile, bool do_update_only, bool remove_highlight);
 
 	int builtin_image_frame(const string &builtin_name);
 	void builtin_image_info(const string &builtin_name, void *builtin_data, bool &is_float, int &width, int &height, int &depth, int &channels);
diff --git a/intern/cycles/blender/blender_shader.cpp b/intern/cycles/blender/blender_shader.cpp
index baf79a7..dcdd2ed 100644
--- a/intern/cycles/blender/blender_shader.cpp
+++ b/intern/cycles/blender/blender_shader.cpp
@@ -321,6 +321,9 @@ static ShaderNode *add_node(Scene *scene, BL::BlendData b_data, BL::Scene b_scen
 	else if (b_node.is_a(&RNA_ShaderNodeHoldout)) {
 		node = new HoldoutNode();
 	}
+	else if (b_node.is_a(&RNA_ShaderNodeShadowCatcher)) {
+		node = new ShadowCatcherNode();
+	}
 	else if (b_node.is_a(&RNA_ShaderNodeBsdfAnisotropic)) {
 		BL::ShaderNodeBsdfAnisotropic b_aniso_node(b_node);
 		AnisotropicBsdfNode *aniso = new AnisotropicBsdfNode();
diff --git a/intern/cycles/blender/blender_sync.cpp b/intern/cycles/blender/blender_sync.cpp
index 985a3cd..604199e 100644
--- a/intern/cycles/blender/blender_sync.cpp
+++ b/intern/cycles/blender/blender_sync.cpp
@@ -194,7 +194,11 @@ void BlenderSync::sync_integrator()
 	integrator->filter_glossy = get_float(cscene, "blur_glossy");
 
 	integrator->seed = get_int(cscene, "seed");
-	integrator->sampling_pattern = (SamplingPattern)RNA_enum_get(&cscene, "sampling_pattern");
+	
+	if(experimental && get_boolean(cscene, "adaptive_stopping"))
+		integrator->sampling_pattern = SAMPLING_PATTERN_SOBOL;
+	else
+		integrator->sampling_pattern = (SamplingPattern)RNA_enum_get(&cscene, "sampling_pattern");
 
 	integrator->layer_flag = render_layer.layer;
 
@@ -521,6 +525,18 @@ SessionParams BlenderSync::get_session_params(BL::RenderEngine b_engine,
 	params.text_timeout = get_float(cscene, "debug_text_timeout");
 
 	params.progressive_refine = get_boolean(cscene, "use_progressive_refine");
+	params.adaptive_stopping = background && params.experimental && get_boolean(cscene, "adaptive_stopping");
+	params.adaptive_distribution = params.adaptive_stopping && get_boolean(cscene, "adaptive_distribution");
+	if(params.adaptive_stopping) {
+		float confidence = get_float(cscene, "adaptive_confidence");
+		confidence = clamp(confidence, 1.0f, 99.999f) * 0.01f;
+		params.stopping_threshold = 1.0f / (M_SQRT2_F*fast_ierff(confidence));
+	}
+	else {
+		params.stopping_threshold = 0;
+	}
+	params.map_interval = get_int(cscene, "adaptive_map_interval");
+	params.error_progressive = params.progressive_refine && params.adaptive_stopping;
 
 	if(background) {
 		if(params.progressive_refine)
diff --git a/intern/cycles/device/device_cpu.cpp b/intern/cycles/device/device_cpu.cpp
index 9abcf91..799ce55 100644
--- a/intern/cycles/device/device_cpu.cpp
+++ b/intern/cycles/device/device_cpu.cpp
@@ -38,6 +38,7 @@
 #include "util_debug.h"
 #include "util_foreach.h"
 #include "util_function.h"
+#include "util_importance.h"
 #include "util_opengl.h"
 #include "util_progress.h"
 #include "util_system.h"
@@ -199,23 +200,40 @@ public:
 		else
 #endif
 			path_trace_kernel = kernel_cpu_path_trace;
-		
+
 		while(task.acquire_tile(this, tile)) {
 			float *render_buffer = (float*)tile.buffer;
 			uint *rng_state = (uint*)tile.rng_state;
 			int start_sample = tile.start_sample;
 			int end_sample = tile.start_sample + tile.num_samples;
 
+			tile.sample = tile.start_sample;
+			ImportanceMap *importance_map = NULL;
+			int next_check = task.adaptive_stopping? 3*task.map_interval: -1;
+
 			for(int sample = start_sample; sample < end_sample; sample++) {
-				if (task.get_cancel() || task_pool.canceled()) {
+				if(task.get_cancel() || task_pool.canceled()) {
 					if(task.need_finish_queue == false)
 						break;
 				}
 
-				for(int y = tile.y; y < tile.y + tile.h; y++) {
-					for(int x = tile.x; x < tile.x + tile.w; x++) {
-						path_trace_kernel(&kg, render_buffer, rng_state,
-						                  sample, x, y, tile.offset, tile.stride);
+				if(sample == next_check) {
+					if(tile_converged(tile, &task, &next_check))
+						break;
+					if(task.adaptive_distribution) {
+						if(importance_map)
+							delete importance_map;
+						importance_map = new ImportanceMap(tile);
+					}
+				}
+
+				for(int y = 0; y < tile.h; y++) {
+					for(int x = 0; x < tile.w; x++) {
+						int px = x, py = y;
+						if(importance_map)
+							importance_map->sample(sample - 3*task.map_interval, px, py);
+						path_trace_kernel(&kg, render_buffer, rng_state, sample,
+								  px + tile.x, py + tile.y, tile.offset, tile.stride);
 					}
 				}
 
@@ -224,6 +242,8 @@ public:
 				task.update_progress(&tile);
 			}
 
+			if(importance_map)
+				delete importance_map;
 			task.release_tile(tile);
 
 			if(task_pool.canceled()) {
@@ -253,13 +273,13 @@ public:
 				for(int y = task.y; y < task.y + task.h; y++)
 				convert_to_half_float_kernel = kernel_cpu_avx_convert_to_half_float;
 			else
-#endif	
-#ifdef WITH_CYCLES_OPTIMIZED_KERNEL_SSE41			
+#endif
+#ifdef WITH_CYCLES_OPTIMIZED_KERNEL_SSE41
 			if(system_cpu_support_sse41())
 				convert_to_half_float_kernel = kernel_cpu_sse41_convert_to_half_float;
 			else
-#endif		
-#ifdef WITH_CYCLES_OPTIMIZED_KERNEL_SSE3		
+#endif
+#ifdef WITH_CYCLES_OPTIMIZED_KERNEL_SSE3
 			if(system_cpu_support_sse3())
 				convert_to_half_float_kernel = kernel_cpu_sse3_convert_to_half_float;
 			else
@@ -332,7 +352,7 @@ public:
 			shader_kernel = kernel_cpu_avx_shader;
 		else
 #endif
-#ifdef WITH_CYCLES_OPTIMIZED_KERNEL_SSE41			
+#ifdef WITH_CYCLES_OPTIMIZED_KERNEL_SSE41
 		if(system_cpu_support_sse41())
 			shader_kernel = kernel_cpu_sse41_shader;
 		else
diff --git a/intern/cycles/device/device_cuda.cpp b/intern/cycles/device/device_cuda.cpp
index 79a1a2b..e32a2bc 100644
--- a/intern/cycles/device/device_cuda.cpp
+++ b/intern/cycles/device/device_cuda.cpp
@@ -26,6 +26,7 @@
 #include "cuew.h"
 #include "util_debug.h"
 #include "util_logging.h"
+#include "util_importance.h"
 #include "util_map.h"
 #include "util_opengl.h"
 #include "util_path.h"
@@ -48,6 +49,7 @@ public:
 	int cuDevArchitecture;
 	bool first_error;
 	bool use_texture_storage;
+	device_vector<int2> adaptive_samples;
 
 	struct PixelMem {
 		GLuint cuPBO;
@@ -570,7 +572,7 @@ public:
 		}
 	}
 
-	void path_trace(RenderTile& rtile, int sample, bool branched)
+	void path_trace(RenderTile& rtile, int sample, bool branched, device_ptr adaptive_samples_ptr)
 	{
 		if(have_error())
 			return;
@@ -580,6 +582,7 @@ public:
 		CUfunction cuPathTrace;
 		CUdeviceptr d_buffer = cuda_device_ptr(rtile.buffer);
 		CUdeviceptr d_rng_state = cuda_device_ptr(rtile.rng_state);
+		CUdeviceptr d_adaptive_samples = cuda_device_ptr(adaptive_samples_ptr);
 
 		/* get kernel function */
 		if(branched) {
@@ -595,6 +598,7 @@ public:
 		/* pass in parameters */
 		void *args[] = {&d_buffer,
 						 &d_rng_state,
+						 &d_adaptive_samples,
 						 &sample,
 						 &rtile.x,
 						 &rtile.y,
@@ -965,13 +969,45 @@ public:
 				int start_sample = tile.start_sample;
 				int end_sample = tile.start_sample + tile.num_samples;
 
+				tile.sample = tile.start_sample;
+				ImportanceMap *importance_map = NULL;
+				int next_check = task->adaptive_stopping? 3*task->map_interval: -1;
+
+				if(task->adaptive_distribution && (adaptive_samples.data_size != tile.w*tile.h)) {
+					adaptive_samples.resize(tile.w*tile.h);
+					mem_free(adaptive_samples);
+					mem_alloc(adaptive_samples, MEM_READ_ONLY);
+				}
+
 				for(int sample = start_sample; sample < end_sample; sample++) {
-					if (task->get_cancel()) {
+					if(task->get_cancel()) {
 						if(task->need_finish_queue == false)
 							break;
 					}
 
-					path_trace(tile, sample, branched);
+					if(sample == next_check) {
+						if(tile_converged(tile, task, &next_check))
+							break;
+						if(task->adaptive_distribution) {
+							if(importance_map)
+								delete importance_map;
+							importance_map = new ImportanceMap(tile);
+						}
+					}
+
+					if(importance_map) {
+						int2 *samples_data = (int2*) adaptive_samples.data_pointer;
+						for(int y = 0; y < tile.h; y++) {
+							for(int x = 0; x < tile.w; x++) {
+								int px = x, py = y;
+								importance_map->sample(sample - 3*task->map_interval, px, py);
+								samples_data[y*tile.w + x] = make_int2(px, py);
+							}
+						}
+						mem_copy_to(adaptive_samples);
+					}
+
+					path_trace(tile, sample, branched, importance_map? adaptive_samples.device_pointer: (device_ptr) NULL);
 
 					tile.sample = sample + 1;
 
diff --git a/intern/cycles/device/device_opencl.cpp b/intern/cycles/device/device_opencl.cpp
index a5bf35a..9544cab 100644
--- a/intern/cycles/device/device_opencl.cpp
+++ b/intern/cycles/device/device_opencl.cpp
@@ -28,6 +28,7 @@
 #include "buffers.h"
 
 #include "util_foreach.h"
+#include "util_importance.h"
 #include "util_map.h"
 #include "util_math.h"
 #include "util_md5.h"
@@ -335,6 +336,7 @@ public:
 	ConstMemMap const_mem_map;
 	MemMap mem_map;
 	device_ptr null_mem;
+	device_vector<int2> adaptive_samples;
 
 	bool device_initialized;
 	string platform_name;
@@ -908,12 +910,13 @@ public:
 		opencl_assert(clFlush(cqCommandQueue));
 	}
 
-	void path_trace(RenderTile& rtile, int sample)
+	void path_trace(RenderTile& rtile, int sample, device_ptr adaptive_samples_ptr)
 	{
 		/* cast arguments to cl types */
 		cl_mem d_data = CL_MEM_PTR(const_mem_map["__data"]->device_pointer);
 		cl_mem d_buffer = CL_MEM_PTR(rtile.buffer);
 		cl_mem d_rng_state = CL_MEM_PTR(rtile.rng_state);
+		cl_mem d_adaptive_samples = CL_MEM_PTR(adaptive_samples_ptr);
 		cl_int d_x = rtile.x;
 		cl_int d_y = rtile.y;
 		cl_int d_w = rtile.w;
@@ -928,6 +931,7 @@ public:
 		opencl_assert(clSetKernelArg(ckPathTraceKernel, narg++, sizeof(d_data), (void*)&d_data));
 		opencl_assert(clSetKernelArg(ckPathTraceKernel, narg++, sizeof(d_buffer), (void*)&d_buffer));
 		opencl_assert(clSetKernelArg(ckPathTraceKernel, narg++, sizeof(d_rng_state), (void*)&d_rng_state));
+		opencl_assert(clSetKernelArg(ckPathTraceKernel, narg++, sizeof(d_adaptive_samples), (void*)&d_adaptive_samples));
 
 #define KERNEL_TEX(type, ttype, name) \
 	set_kernel_arg_mem(ckPathTraceKernel, &narg, #name);
@@ -1065,13 +1069,44 @@ public:
 				int start_sample = tile.start_sample;
 				int end_sample = tile.start_sample + tile.num_samples;
 
+				tile.sample = tile.start_sample;
+				ImportanceMap *importance_map = NULL;
+				int next_check = task->adaptive_stopping? 3*task->map_interval: -1;
+
 				for(int sample = start_sample; sample < end_sample; sample++) {
 					if(task->get_cancel()) {
 						if(task->need_finish_queue == false)
 							break;
 					}
 
-					path_trace(tile, sample);
+					if(sample == next_check) {
+						if(tile_converged(tile, task, &next_check))
+							break;
+						if(task->adaptive_distribution) {
+							if(importance_map) delete
+								importance_map;
+							importance_map = new ImportanceMap(tile);
+						}
+					}
+
+					if(importance_map) {
+						if(sample == start_sample) {
+							adaptive_samples.resize(tile.w*tile.h);
+							mem_free(adaptive_samples);
+							mem_alloc(adaptive_samples, MEM_READ_ONLY);
+						}
+						int2 *samples_data = (int2*) adaptive_samples.data_pointer;
+						for(int y = 0; y < tile.h; y++) {
+							for(int x = 0; x < tile.w; x++) {
+								int px = x, py = y;
+								importance_map->sample(sample - 3*task->map_interval, px, py);
+								samples_data[y*tile.w + x] = make_int2(px, py);
+							}
+						}
+						mem_copy_to(adaptive_samples);
+					}
+
+					path_trace(tile, sample, importance_map? adaptive_samples.device_pointer: (device_ptr) NULL);
 
 					tile.sample = sample + 1;
 
diff --git a/intern/cycles/device/device_task.h b/intern/cycles/device/device_task.h
index 84945bc..25bf735 100644
--- a/intern/cycles/device/device_task.h
+++ b/intern/cycles/device/device_task.h
@@ -45,6 +45,12 @@ public:
 	int num_samples;
 	int offset, stride;
 
+	bool adaptive_stopping;
+	bool adaptive_distribution;
+	float stopping_threshold;
+	int map_interval;
+	bool error_progressive;
+
 	device_ptr shader_input;
 	device_ptr shader_output;
 	int shader_eval_type;
diff --git a/intern/cycles/kernel/kernel.cl b/intern/cycles/kernel/kernel.cl
index 5a47260..c51f866 100644
--- a/intern/cycles/kernel/kernel.cl
+++ b/intern/cycles/kernel/kernel.cl
@@ -29,6 +29,7 @@ __kernel void kernel_ocl_path_trace(
 	ccl_constant KernelData *data,
 	ccl_global float *buffer,
 	ccl_global uint *rng_state,
+	ccl_global uint2 *pixel_mapping,
 
 #define KERNEL_TEX(type, ttype, name) \
 	ccl_global type *name,
@@ -45,11 +46,19 @@ __kernel void kernel_ocl_path_trace(
 	kg->name = name;
 #include "kernel_textures.h"
 
-	int x = sx + get_global_id(0);
-	int y = sy + get_global_id(1);
+	int x = get_global_id(0);
+	int y = get_global_id(1);
 
-	if(x < sx + sw && y < sy + sh)
-		kernel_path_trace(kg, buffer, rng_state, sample, x, y, offset, stride);
+#ifdef __ADAPTIVE__
+	if(pixel_mapping != NULL && x < sw && y < sh) {
+		uint2 pos = pixel_mapping[y*sw + x];
+		x = pos.x;
+		y = pos.y;
+	}
+#endif
+
+	if(x < sw && y < sh)
+		kernel_path_trace(kg, buffer, rng_state, sample, sx + x, sy + y, offset, stride);
 }
 
 __kernel void kernel_ocl_convert_to_byte(
diff --git a/intern/cycles/kernel/kernel.cu b/intern/cycles/kernel/kernel.cu
index 64069fc..30bf9f1 100644
--- a/intern/cycles/kernel/kernel.cu
+++ b/intern/cycles/kernel/kernel.cu
@@ -112,25 +112,41 @@
 
 extern "C" __global__ void
 CUDA_LAUNCH_BOUNDS(CUDA_THREADS_BLOCK_WIDTH, CUDA_KERNEL_MAX_REGISTERS)
-kernel_cuda_path_trace(float *buffer, uint *rng_state, int sample, int sx, int sy, int sw, int sh, int offset, int stride)
+kernel_cuda_path_trace(float *buffer, uint *rng_state, uint2 *pixel_mapping, int sample, int sx, int sy, int sw, int sh, int offset, int stride)
 {
-	int x = sx + blockDim.x*blockIdx.x + threadIdx.x;
-	int y = sy + blockDim.y*blockIdx.y + threadIdx.y;
+	int x = blockDim.x*blockIdx.x + threadIdx.x;
+	int y = blockDim.y*blockIdx.y + threadIdx.y;
+
+#ifdef __ADAPTIVE__
+	if(pixel_mapping != NULL && x < sw && y < sh) {
+		uint2 pos = pixel_mapping[y*sw + x];
+		x = pos.x;
+		y = pos.y;
+	}
+#endif
 
-	if(x < sx + sw && y < sy + sh)
-		kernel_path_trace(NULL, buffer, rng_state, sample, x, y, offset, stride);
+	if(x < sw && y < sh)
+		kernel_path_trace(NULL, buffer, rng_state, sample, sx + x, sy + y, offset, stride);
 }
 
 #ifdef __BRANCHED_PATH__
 extern "C" __global__ void
 CUDA_LAUNCH_BOUNDS(CUDA_THREADS_BLOCK_WIDTH, CUDA_KERNEL_BRANCHED_MAX_REGISTERS)
-kernel_cuda_branched_path_trace(float *buffer, uint *rng_state, int sample, int sx, int sy, int sw, int sh, int offset, int stride)
+kernel_cuda_branched_path_trace(float *buffer, uint *rng_state, uint2 *pixel_mapping, int sample, int sx, int sy, int sw, int sh, int offset, int stride)
 {
-	int x = sx + blockDim.x*blockIdx.x + threadIdx.x;
-	int y = sy + blockDim.y*blockIdx.y + threadIdx.y;
+	int x = blockDim.x*blockIdx.x + threadIdx.x;
+	int y = blockDim.y*blockIdx.y + threadIdx.y;
+
+#ifdef __ADAPTIVE__
+	if(pixel_mapping != NULL && x < sw && y < sh) {
+		uint2 pos = pixel_mapping[y*sw + x];
+		x = pos.x;
+		y = pos.y;
+	}
+#endif
 
-	if(x < sx + sw && y < sy + sh)
-		kernel_branched_path_trace(NULL, buffer, rng_state, sample, x, y, offset, stride);
+	if(x < sw && y < sh)
+		kernel_branched_path_trace(NULL, buffer, rng_state, sample, sx + x, sy + y, offset, stride);
 }
 #endif
 
diff --git a/intern/cycles/kernel/kernel_compat_opencl.h b/intern/cycles/kernel/kernel_compat_opencl.h
index d480ec0..75ab84d 100644
--- a/intern/cycles/kernel/kernel_compat_opencl.h
+++ b/intern/cycles/kernel/kernel_compat_opencl.h
@@ -117,5 +117,19 @@
 #include "util_half.h"
 #include "util_types.h"
 
+float atomicAdd(ccl_global float* address, float val)
+{
+	ccl_global volatile unsigned int* address_as_u =
+			(ccl_global volatile unsigned int*)address;
+	unsigned int old = *address_as_u, assumed;
+	do {
+		assumed = old;
+		old = atomic_cmpxchg(address_as_u, assumed,
+						__float_as_int(val +
+						__int_as_float(assumed)));
+	} while (assumed != old);
+	return __int_as_float(old);
+}
+
 #endif /* __KERNEL_COMPAT_OPENCL_H__ */
 
diff --git a/intern/cycles/kernel/kernel_debug.h b/intern/cycles/kernel/kernel_debug.h
index f532442..fa0a103 100644
--- a/intern/cycles/kernel/kernel_debug.h
+++ b/intern/cycles/kernel/kernel_debug.h
@@ -29,9 +29,8 @@ ccl_device_inline void kernel_write_debug_passes(KernelGlobals *kg,
 {
 	int flag = kernel_data.film.pass_flag;
 	if(flag & PASS_BVH_TRAVERSAL_STEPS) {
-		kernel_write_pass_float(buffer + kernel_data.film.pass_bvh_traversal_steps,
-		                        sample,
-		                        debug_data->num_bvh_traversal_steps);
+		kernel_write_pass_float(kg, buffer + kernel_data.film.pass_bvh_traversal_steps,
+		                        sample, debug_data->num_bvh_traversal_steps);
 	}
 }
 
diff --git a/intern/cycles/kernel/kernel_emission.h b/intern/cycles/kernel/kernel_emission.h
index d3cbc5c..6c5a5fa 100644
--- a/intern/cycles/kernel/kernel_emission.h
+++ b/intern/cycles/kernel/kernel_emission.h
@@ -254,7 +254,7 @@ ccl_device_noinline float3 indirect_background(KernelGlobals *kg, PathState *sta
 	if(!(state->flag & PATH_RAY_MIS_SKIP) && res) {
 		/* multiple importance sampling, get background light pdf for ray
 		 * direction, and compute weight with respect to BSDF pdf */
-		float pdf = background_light_pdf(kg, ray->D);
+		float pdf = background_light_pdf(kg, ray->P, ray->D);
 		float mis_weight = power_heuristic(state->ray_pdf, pdf);
 
 		return L*mis_weight;
diff --git a/intern/cycles/kernel/kernel_light.h b/intern/cycles/kernel/kernel_light.h
index 76fa754..314f5e0 100644
--- a/intern/cycles/kernel/kernel_light.h
+++ b/intern/cycles/kernel/kernel_light.h
@@ -33,6 +33,98 @@ typedef struct LightSample {
 	LightType type;		/* type of light */
 } LightSample;
 
+/* Area light sampling */
+
+/* Uses the following paper:
+ *
+ * Carlos Urena et al.
+ * An Area-Preserving Parametrization for Spherical Rectangles.
+ *
+ * https://www.solidangle.com/research/egsr2013_spherical_rectangle.pdf
+ *
+ * Note: light_p is modified when sample_coord is true.
+ */
+ccl_device float area_light_sample(float3 P,
+                                   float3 *light_p,
+                                   float3 axisu, float3 axisv,
+                                   float randu, float randv,
+                                   bool sample_coord)
+{
+	/* In our name system we're using P for the center,
+	* which is o in the paper.
+	*/
+
+	float3 corner = *light_p - axisu * 0.5f - axisv * 0.5f;
+	float axisu_len, axisv_len;
+	/* Compute local reference system R. */
+	float3 x = normalize_len(axisu, &axisu_len);
+	float3 y = normalize_len(axisv, &axisv_len);
+	float3 z = cross(x, y);
+	/* Compute rectangle coords in local reference system. */
+	float3 dir = corner - P;
+	float z0 = dot(dir, z);
+	/* Flip 'z' to make it point against Q. */
+	if(z0 > 0.0f) {
+		z *= -1.0f;
+		z0 *= -1.0f;
+	}
+	float x0 = dot(dir, x);
+	float y0 = dot(dir, y);
+	float x1 = x0 + axisu_len;
+	float y1 = y0 + axisv_len;
+	/* Create vectors to four vertices. */
+	float3 v00 = make_float3(x0, y0, z0);
+	float3 v01 = make_float3(x0, y1, z0);
+	float3 v10 = make_float3(x1, y0, z0);
+	float3 v11 = make_float3(x1, y1, z0);
+	/* Compute normals to edges. */
+	float3 n0 = normalize(cross(v00, v10));
+	float3 n1 = normalize(cross(v10, v11));
+	float3 n2 = normalize(cross(v11, v01));
+	float3 n3 = normalize(cross(v01, v00));
+	/* Compute internal angles (gamma_i). */
+	float g0 = safe_acosf(-dot(n0, n1));
+	float g1 = safe_acosf(-dot(n1, n2));
+	float g2 = safe_acosf(-dot(n2, n3));
+	float g3 = safe_acosf(-dot(n3, n0));
+	/* Compute predefined constants. */
+	float b0 = n0.z;
+	float b1 = n2.z;
+	float b0sq = b0 * b0;
+	float k = M_2PI_F - g2 - g3;
+	/* Compute solid angle from internal angles. */
+	float S = g0 + g1 - k;
+
+	if(sample_coord) {
+		/* Compute cu. */
+		float au = randu * S + k;
+		float fu = (cosf(au) * b0 - b1) / sinf(au);
+		float cu = 1.0f / sqrtf(fu * fu + b0sq) * (fu > 0.0f ? 1.0f : -1.0f);
+		cu = clamp(cu, -1.0f, 1.0f);
+		/* Compute xu. */
+		float xu = -(cu * z0) / sqrtf(1.0f - cu * cu);
+		xu = clamp(xu, x0, x1);
+		/* Compute yv. */
+		float z0sq = z0 * z0;
+		float y0sq = y0 * y0;
+		float y1sq = y1 * y1;
+		float d = sqrtf(xu * xu + z0sq);
+		float h0 = y0 / sqrtf(d * d + y0sq);
+		float h1 = y1 / sqrtf(d * d + y1sq);
+		float hv = h0 + randv * (h1 - h0), hv2 = hv * hv;
+		float yv = (hv2 < 1.0f - 1e-6f) ? (hv * d) / sqrtf(1.0f - hv2) : y1;
+
+		/* Transform (xu, yv, z0) to world coords. */
+		*light_p = P + xu * x + yv * y + z0 * z;
+	}
+
+	/* return pdf */
+	if(S != 0.0f)
+		return 1.0f / S;
+	else
+		return 0.0f;
+}
+
 /* Background Light */
 
 #ifdef __BACKGROUND_MIS__
@@ -46,11 +138,11 @@ ccl_device_noinline
 #else
 ccl_device
 #endif
-float3 background_light_sample(KernelGlobals *kg, float randu, float randv, float *pdf)
+float3 background_sample_cdf(KernelGlobals *kg, float randu, float randv, float *pdf)
 {
 	/* for the following, the CDF values are actually a pair of floats, with the
-	 * function value as X and the actual CDF as Y.  The last entry's function
-	 * value is the CDF total. */
+	* function value as X and the actual CDF as Y.  The last entry's function
+	* value is the CDF total. */
 	int res = kernel_data.integrator.pdf_background_res;
 	int cdf_count = res + 1;
 
@@ -58,11 +150,11 @@ float3 background_light_sample(KernelGlobals *kg, float randu, float randv, floa
 	int first = 0;
 	int count = res;
 
-	while(count > 0) {
+	while (count > 0) {
 		int step = count >> 1;
 		int middle = first + step;
 
-		if(kernel_tex_fetch(__light_background_marginal_cdf, middle).y < randv) {
+		if (kernel_tex_fetch(__light_background_marginal_cdf, middle).y < randv) {
 			first = middle + 1;
 			count -= step + 1;
 		}
@@ -84,11 +176,11 @@ float3 background_light_sample(KernelGlobals *kg, float randu, float randv, floa
 	/* this is basically std::lower_bound as used by pbrt */
 	first = 0;
 	count = res;
-	while(count > 0) {
+	while (count > 0) {
 		int step = count >> 1;
 		int middle = first + step;
 
-		if(kernel_tex_fetch(__light_background_conditional_cdf, index_v * cdf_count + middle).y < randu) {
+		if (kernel_tex_fetch(__light_background_conditional_cdf, index_v * cdf_count + middle).y < randu) {
 			first = middle + 1;
 			count -= step + 1;
 		}
@@ -111,15 +203,13 @@ float3 background_light_sample(KernelGlobals *kg, float randu, float randv, floa
 	float denom = cdf_last_u.x * cdf_last_v.x;
 	float sin_theta = sinf(M_PI_F * v);
 
-	if(sin_theta == 0.0f || denom == 0.0f)
+	if (sin_theta == 0.0f || denom == 0.0f)
 		*pdf = 0.0f;
 	else
-		*pdf = (cdf_u.x * cdf_v.x)/(M_2PI_F * M_PI_F * sin_theta * denom);
-
-	*pdf *= kernel_data.integrator.pdf_lights;
+		*pdf = (cdf_u.x * cdf_v.x) / (M_2PI_F * M_PI_F * sin_theta * denom);
 
 	/* compute direction */
-	return -equirectangular_to_direction(u, v);
+	return equirectangular_to_direction(u, v);
 }
 
 /* TODO(sergey): Same as above, after the release we should consider using
@@ -130,7 +220,7 @@ ccl_device_noinline
 #else
 ccl_device
 #endif
-float background_light_pdf(KernelGlobals *kg, float3 direction)
+float background_pdf_cdf(KernelGlobals *kg, float3 direction)
 {
 	float2 uv = direction_to_equirectangular(direction);
 	int res = kernel_data.integrator.pdf_background_res;
@@ -156,9 +246,183 @@ float background_light_pdf(KernelGlobals *kg, float3 direction)
 	float2 cdf_u = kernel_tex_fetch(__light_background_conditional_cdf, index_v * (res + 1) + index_u);
 	float2 cdf_v = kernel_tex_fetch(__light_background_marginal_cdf, index_v);
 
-	float pdf = (cdf_u.x * cdf_v.x)/(M_2PI_F * M_PI_F * sin_theta * denom);
+	return (cdf_u.x * cdf_v.x)/(M_2PI_F * M_PI_F * sin_theta * denom);
+}
+
+ccl_device float background_pdf_portal(KernelGlobals *kg, float3 P, float3 direction, int ignore_portal, int *num_possible) {
+	float portal_pdf = 0.0f;
+	if (num_possible)
+		*num_possible = 0;
+
+	for (int p = 0; p < kernel_data.integrator.num_portals; p++) {
+		if(p == ignore_portal)
+			continue;
+
+		float4 data0 = kernel_tex_fetch(__light_data, (p + kernel_data.integrator.portal_offset)*LIGHT_SIZE + 0);
+		float4 data1 = kernel_tex_fetch(__light_data, (p + kernel_data.integrator.portal_offset)*LIGHT_SIZE + 1);
+		float4 data2 = kernel_tex_fetch(__light_data, (p + kernel_data.integrator.portal_offset)*LIGHT_SIZE + 2);
+		float4 data3 = kernel_tex_fetch(__light_data, (p + kernel_data.integrator.portal_offset)*LIGHT_SIZE + 3);
+
+		float3 lightpos = make_float3(data0.y, data0.z, data0.w);
+		float3 axisu = make_float3(data1.y, data1.z, data1.w);
+		float3 axisv = make_float3(data2.y, data2.z, data2.w);
+		float3 dir = make_float3(data3.y, data3.z, data3.w);
+
+		//Hits portal?
+		float dist = dot(dir, P - lightpos);
+		if (dist <= 1e-5f)
+			continue; //P is on the wrong side or too close!
+
+		if (num_possible)
+			(*num_possible)++; //Accumulate portals that could be sampled from this position
 
-	return pdf * kernel_data.integrator.pdf_lights;
+		//if(dot(dir, direction) > 0.0f)
+			//continue; //Direction points away from portal!
+
+		float t = -(dot(P, dir) - dot(lightpos, dir)) / dot(direction, dir);
+		if (t <= 0) continue;
+		float3 hit = P + t*direction;
+		float3 inplane = hit - lightpos;
+		if (fabsf(dot(inplane, axisu) / dot(axisu, axisu)) > 0.5f) continue;
+		if (fabsf(dot(inplane, axisv) / dot(axisv, axisv)) > 0.5f) continue;
+
+		portal_pdf += area_light_sample(P, &lightpos, axisu, axisv, 0, 0, false);
+	}
+
+	return kernel_data.integrator.num_portals? portal_pdf / kernel_data.integrator.num_portals: 0.0f;
+}
+
+ccl_device int background_num_portals(KernelGlobals *kg, float3 P) {
+	int num_possible_portals = 0;
+	for(int p = 0; p < kernel_data.integrator.num_portals; p++) {
+		float4 data0 = kernel_tex_fetch(__light_data, (p + kernel_data.integrator.portal_offset)*LIGHT_SIZE + 0);
+		float4 data3 = kernel_tex_fetch(__light_data, (p + kernel_data.integrator.portal_offset)*LIGHT_SIZE + 3);
+		float3 lightpos = make_float3(data0.y, data0.z, data0.w);
+		float3 dir = make_float3(data3.y, data3.z, data3.w);
+
+		float dist = dot(dir, P - lightpos);
+
+		if (dist > 1e-5f)
+			num_possible_portals++;
+	}
+	return num_possible_portals;
+}
+
+ccl_device float3 background_sample_portal(KernelGlobals *kg, float3 P, float randu, float randv, int num_possible, int *sampled, float *pdf) {
+	//Pick a portal, then re-normalize randv
+	randv *= num_possible;
+	int portal = (int)randv;
+	randv -= portal;
+
+	for(int p = 0; p < kernel_data.integrator.num_portals; p++) { //Search for the portal
+		float4 data0 = kernel_tex_fetch(__light_data, (p + kernel_data.integrator.portal_offset)*LIGHT_SIZE + 0);
+		float4 data3 = kernel_tex_fetch(__light_data, (p + kernel_data.integrator.portal_offset)*LIGHT_SIZE + 3);
+		float3 lightpos = make_float3(data0.y, data0.z, data0.w);
+		float3 dir = make_float3(data3.y, data3.z, data3.w);
+
+		float dist = dot(dir, P - lightpos);
+
+		if (dist <= 1e-5f)
+			continue;
+
+		if(portal == 0) { //p is the portal to be sampled
+			float4 data1 = kernel_tex_fetch(__light_data, (p + kernel_data.integrator.portal_offset)*LIGHT_SIZE + 1);
+			float4 data2 = kernel_tex_fetch(__light_data, (p + kernel_data.integrator.portal_offset)*LIGHT_SIZE + 2);
+			float3 axisu = make_float3(data1.y, data1.z, data1.w);
+			float3 axisv = make_float3(data2.y, data2.z, data2.w);
+
+			float3 lightPoint = lightpos;
+
+			*pdf = area_light_sample(P, &lightPoint,
+									 axisu, axisv,
+									 randu, randv,
+									 true);
+
+			*pdf /= num_possible;
+			*sampled = p;
+			return normalize(lightPoint - P);
+		}
+
+		portal--;
+	}
+
+	return make_float3(0, 0, 0);
+}
+
+ccl_device float3 background_light_sample(KernelGlobals *kg, float3 P, float randu, float randv, float *pdf)
+{
+	//Probability of sampling portals instead of the background
+	float portal_s_pdf = kernel_data.integrator.portal_pdf;
+
+	if (portal_s_pdf > 0.0f) { //Are there portals in the scene?
+		//Can we find a portal?
+		int num_portals = background_num_portals(kg, P);
+		if (num_portals > 0) {
+			//We can!
+			if (portal_s_pdf == 1.0f || randu < portal_s_pdf) { //Should we sample a portal?
+				//Yes, so do so!
+				if (portal_s_pdf < 1.0f)
+					randu /= portal_s_pdf;
+				int portal; //The sampled portal
+				float3 D = background_sample_portal(kg, P, randu, randv, num_portals, &portal, pdf);
+				if (num_portals > 1) { //Use MIS for the portal sampling?
+					*pdf += background_pdf_portal(kg, P, D, portal, NULL); //Ignore the chosen portal, its pdf is already included
+				}
+				if (portal_s_pdf < 1.0f) { //We could also have sampled the background, so combine with MIS
+					float cdf_pdf = background_pdf_cdf(kg, D);
+					*pdf = (portal_s_pdf * (*pdf) + (1.0f - portal_s_pdf) * cdf_pdf);
+				}
+				return D;
+			} else {
+				//Sample background, but with nonzero portal_s_pdf for MIS
+				randu = (randu - portal_s_pdf) / (1.0f - portal_s_pdf);
+			}
+		} else {
+			//We can's sample a portal!
+			if (portal_s_pdf == 1.0f) { //Can we sample background?
+				 //We can't sample the background either, so return uniform as a fallback!
+				*pdf = 1.0f / M_4PI_F;
+				return sample_uniform_sphere(randu, randv);
+			}
+			else
+				portal_s_pdf = 0.0f; //Sample the background instead
+		}
+	}
+
+	float3 D = background_sample_cdf(kg, randu, randv, pdf);
+	//Could light portals be sampled? If yes, use MIS!
+	if (portal_s_pdf > 0.0f) {
+		float portal_pdf = background_pdf_portal(kg, P, D, -1, NULL);
+		*pdf = (portal_s_pdf * portal_pdf + (1.0f - portal_s_pdf) * (*pdf));
+	}
+	return D;
+}
+
+ccl_device float background_light_pdf(KernelGlobals *kg, float3 P, float3 direction)
+{
+	//Probability of sampling portals instead of the background
+	float portal_s_pdf = kernel_data.integrator.portal_pdf;
+
+	if (portal_s_pdf > 0.0f) { //Are there portals in the scene?
+		int num_possible;
+		float portal_pdf = background_pdf_portal(kg, P, direction, -1, &num_possible);
+		if (portal_pdf == 0.0f) {
+			if (portal_s_pdf == 1.0f) //Could sample background?
+				//If there are no possible portals at this point, the fallback sampling would have been used
+				//Otherwise, the direction is simply wrong
+				return (num_possible > 0)? 0.0f: 1.0f / M_4PI_F;
+			else
+				return background_pdf_cdf(kg, direction); //Can only sample background, all portals are unusable
+		} else {
+			if (portal_s_pdf == 1.0f)
+				return portal_pdf; //Can only sample portals, not the background
+			else
+				return background_pdf_cdf(kg, direction) * (1.0f - portal_s_pdf)
+					 + portal_pdf * portal_s_pdf; //Can sample both, so combine them with MIS
+		}
+	}
+	//If there were no portals and no CDF, this function wouldn't be called
+	return background_pdf_cdf(kg, direction); //No portals in the scene
 }
 #endif
 
@@ -184,96 +448,6 @@ ccl_device float3 sphere_light_sample(float3 P, float3 center, float radius, flo
 	return disk_light_sample(normalize(P - center), randu, randv)*radius;
 }
 
-/* Uses the following paper:
- *
- * Carlos Urena et al.
- * An Area-Preserving Parametrization for Spherical Rectangles.
- *
- * https://www.solidangle.com/research/egsr2013_spherical_rectangle.pdf
- *
- * Note: light_p is modified when sample_coord is true.
- */
-ccl_device float area_light_sample(float3 P,
-                                   float3 *light_p,
-                                   float3 axisu, float3 axisv,
-                                   float randu, float randv,
-                                   bool sample_coord)
-{
-	/* In our name system we're using P for the center,
-	 * which is o in the paper.
-	 */
-
-	float3 corner = *light_p - axisu * 0.5f - axisv * 0.5f;
-	float axisu_len, axisv_len;
-	/* Compute local reference system R. */
-	float3 x = normalize_len(axisu, &axisu_len);
-	float3 y = normalize_len(axisv, &axisv_len);
-	float3 z = cross(x, y);
-	/* Compute rectangle coords in local reference system. */
-	float3 dir = corner - P;
-	float z0 = dot(dir, z);
-	/* Flip 'z' to make it point against Q. */
-	if(z0 > 0.0f) {
-		z *= -1.0f;
-		z0 *= -1.0f;
-	}
-	float x0 = dot(dir, x);
-	float y0 = dot(dir, y);
-	float x1 = x0 + axisu_len;
-	float y1 = y0 + axisv_len;
-	/* Create vectors to four vertices. */
-	float3 v00 = make_float3(x0, y0, z0);
-	float3 v01 = make_float3(x0, y1, z0);
-	float3 v10 = make_float3(x1, y0, z0);
-	float3 v11 = make_float3(x1, y1, z0);
-	/* Compute normals to edges. */
-	float3 n0 = normalize(cross(v00, v10));
-	float3 n1 = normalize(cross(v10, v11));
-	float3 n2 = normalize(cross(v11, v01));
-	float3 n3 = normalize(cross(v01, v00));
-	/* Compute internal angles (gamma_i). */
-	float g0 = safe_acosf(-dot(n0, n1));
-	float g1 = safe_acosf(-dot(n1, n2));
-	float g2 = safe_acosf(-dot(n2, n3));
-	float g3 = safe_acosf(-dot(n3, n0));
-	/* Compute predefined constants. */
-	float b0 = n0.z;
-	float b1 = n2.z;
-	float b0sq = b0 * b0;
-	float k = M_2PI_F - g2 - g3;
-	/* Compute solid angle from internal angles. */
-	float S = g0 + g1 - k;
-
-	if(sample_coord) {
-		/* Compute cu. */
-		float au = randu * S + k;
-		float fu = (cosf(au) * b0 - b1) / sinf(au);
-		float cu = 1.0f / sqrtf(fu * fu + b0sq) * (fu > 0.0f ? 1.0f : -1.0f);
-		cu = clamp(cu, -1.0f, 1.0f);
-		/* Compute xu. */
-		float xu = -(cu * z0) / sqrtf(1.0f - cu * cu);
-		xu = clamp(xu, x0, x1);
-		/* Compute yv. */
-		float z0sq = z0 * z0;
-		float y0sq = y0 * y0;
-		float y1sq = y1 * y1;
-		float d = sqrtf(xu * xu + z0sq);
-		float h0 = y0 / sqrtf(d * d + y0sq);
-		float h1 = y1 / sqrtf(d * d + y1sq);
-		float hv = h0 + randv * (h1 - h0), hv2 = hv * hv;
-		float yv = (hv2 < 1.0f - 1e-6f) ? (hv * d) / sqrtf(1.0f - hv2) : y1;
-
-		/* Transform (xu, yv, z0) to world coords. */
-		*light_p = P + xu * x + yv * y + z0 * z;
-	}
-
-	/* return pdf */
-	if(S != 0.0f)
-		return 1.0f / S;
-	else
-		return 0.0f;
-}
-
 ccl_device float spot_light_attenuation(float4 data1, float4 data2, LightSample *ls)
 {
 	float3 dir = make_float3(data2.y, data2.z, data2.w);
@@ -344,13 +518,14 @@ ccl_device void lamp_light_sample(KernelGlobals *kg, int lamp,
 #ifdef __BACKGROUND_MIS__
 	else if(type == LIGHT_BACKGROUND) {
 		/* infinite area light (e.g. light dome or env light) */
-		float3 D = background_light_sample(kg, randu, randv, &ls->pdf);
+		float3 D = -background_light_sample(kg, P, randu, randv, &ls->pdf);
 
 		ls->P = D;
 		ls->Ng = D;
 		ls->D = -D;
 		ls->t = FLT_MAX;
 		ls->eval_fac = 1.0f;
+		ls->pdf *= kernel_data.integrator.pdf_lights;
 	}
 #endif
 	else {
diff --git a/intern/cycles/kernel/kernel_passes.h b/intern/cycles/kernel/kernel_passes.h
index 6bb39ee..440b6dd 100644
--- a/intern/cycles/kernel/kernel_passes.h
+++ b/intern/cycles/kernel/kernel_passes.h
@@ -14,24 +14,54 @@
  * limitations under the License.
  */
 
+#include "kernel_types.h"
+
 CCL_NAMESPACE_BEGIN
 
-ccl_device_inline void kernel_write_pass_float(ccl_global float *buffer, int sample, float value)
+ccl_device_inline void kernel_write_pass_float(KernelGlobals *kg, ccl_global float *buffer, int sample, float value)
 {
 	ccl_global float *buf = buffer;
-	*buf = (sample == 0)? value: *buf + value;
+	if(sample == 0)
+		*buf = value;
+#if defined(__ADAPTIVE__) && defined(__KERNEL_GPU__)
+	else if(kernel_data.film.use_atomics)
+		atomicAdd(buffer, value);
+#endif
+	else
+		*buf = *buf + value;
 }
 
-ccl_device_inline void kernel_write_pass_float3(ccl_global float *buffer, int sample, float3 value)
+ccl_device_inline void kernel_write_pass_float3(KernelGlobals *kg, ccl_global float *buffer, int sample, float3 value)
 {
 	ccl_global float3 *buf = (ccl_global float3*)buffer;
-	*buf = (sample == 0)? value: *buf + value;
+	if(sample == 0)
+		*buf = value;
+#if defined(__ADAPTIVE__) && defined(__KERNEL_GPU__)
+	else if(kernel_data.film.use_atomics) {
+		atomicAdd(buffer  , value.x);
+		atomicAdd(buffer+1, value.y);
+		atomicAdd(buffer+2, value.z);
+	}
+#endif
+	else
+		*buf = *buf + value;
 }
 
-ccl_device_inline void kernel_write_pass_float4(ccl_global float *buffer, int sample, float4 value)
+ccl_device_inline void kernel_write_pass_float4(KernelGlobals *kg, ccl_global float *buffer, int sample, float4 value)
 {
 	ccl_global float4 *buf = (ccl_global float4*)buffer;
-	*buf = (sample == 0)? value: *buf + value;
+	if(sample == 0)
+		*buf = value;
+#if defined(__ADAPTIVE__) && defined(__KERNEL_GPU__)
+	else if(kernel_data.film.use_atomics) {
+		atomicAdd(buffer  , value.x);
+		atomicAdd(buffer+1, value.y);
+		atomicAdd(buffer+2, value.z);
+		atomicAdd(buffer+3, value.w);
+	}
+#endif
+	else
+		*buf = *buf + value;
 }
 
 ccl_device_inline void kernel_write_data_passes(KernelGlobals *kg, ccl_global float *buffer, PathRadiance *L,
@@ -47,7 +77,7 @@ ccl_device_inline void kernel_write_data_passes(KernelGlobals *kg, ccl_global fl
 
 	if(!(flag & PASS_ALL))
 		return;
-	
+
 	if(!(path_flag & PATH_RAY_SINGLE_PASS_DONE)) {
 		if(!(sd->flag & SD_TRANSPARENT) ||
 		   kernel_data.film.pass_alpha_threshold == 0.0f ||
@@ -57,30 +87,30 @@ ccl_device_inline void kernel_write_data_passes(KernelGlobals *kg, ccl_global fl
 			if(sample == 0) {
 				if(flag & PASS_DEPTH) {
 					float depth = camera_distance(kg, sd->P);
-					kernel_write_pass_float(buffer + kernel_data.film.pass_depth, sample, depth);
+					kernel_write_pass_float(kg, buffer + kernel_data.film.pass_depth, sample, depth);
 				}
 				if(flag & PASS_OBJECT_ID) {
 					float id = object_pass_id(kg, sd->object);
-					kernel_write_pass_float(buffer + kernel_data.film.pass_object_id, sample, id);
+					kernel_write_pass_float(kg, buffer + kernel_data.film.pass_object_id, sample, id);
 				}
 				if(flag & PASS_MATERIAL_ID) {
 					float id = shader_pass_id(kg, sd);
-					kernel_write_pass_float(buffer + kernel_data.film.pass_material_id, sample, id);
+					kernel_write_pass_float(kg, buffer + kernel_data.film.pass_material_id, sample, id);
 				}
 			}
 
 			if(flag & PASS_NORMAL) {
 				float3 normal = sd->N;
-				kernel_write_pass_float3(buffer + kernel_data.film.pass_normal, sample, normal);
+				kernel_write_pass_float3(kg, buffer + kernel_data.film.pass_normal, sample, normal);
 			}
 			if(flag & PASS_UV) {
 				float3 uv = primitive_uv(kg, sd);
-				kernel_write_pass_float3(buffer + kernel_data.film.pass_uv, sample, uv);
+				kernel_write_pass_float3(kg, buffer + kernel_data.film.pass_uv, sample, uv);
 			}
 			if(flag & PASS_MOTION) {
 				float4 speed = primitive_motion_vector(kg, sd);
-				kernel_write_pass_float4(buffer + kernel_data.film.pass_motion, sample, speed);
-				kernel_write_pass_float(buffer + kernel_data.film.pass_motion_weight, sample, 1.0f);
+				kernel_write_pass_float4(kg, buffer + kernel_data.film.pass_motion, sample, speed);
+				kernel_write_pass_float(kg, buffer + kernel_data.film.pass_motion_weight, sample, 1.0f);
 			}
 
 			state->flag |= PATH_RAY_SINGLE_PASS_DONE;
@@ -130,46 +160,71 @@ ccl_device_inline void kernel_write_light_passes(KernelGlobals *kg, ccl_global f
 
 	if(!kernel_data.film.use_light_pass)
 		return;
-	
+
 	if(flag & PASS_DIFFUSE_INDIRECT)
-		kernel_write_pass_float3(buffer + kernel_data.film.pass_diffuse_indirect, sample, L->indirect_diffuse);
+		kernel_write_pass_float3(kg, buffer + kernel_data.film.pass_diffuse_indirect, sample, L->indirect_diffuse);
 	if(flag & PASS_GLOSSY_INDIRECT)
-		kernel_write_pass_float3(buffer + kernel_data.film.pass_glossy_indirect, sample, L->indirect_glossy);
+		kernel_write_pass_float3(kg, buffer + kernel_data.film.pass_glossy_indirect, sample, L->indirect_glossy);
 	if(flag & PASS_TRANSMISSION_INDIRECT)
-		kernel_write_pass_float3(buffer + kernel_data.film.pass_transmission_indirect, sample, L->indirect_transmission);
+		kernel_write_pass_float3(kg, buffer + kernel_data.film.pass_transmission_indirect, sample, L->indirect_transmission);
 	if(flag & PASS_SUBSURFACE_INDIRECT)
-		kernel_write_pass_float3(buffer + kernel_data.film.pass_subsurface_indirect, sample, L->indirect_subsurface);
+		kernel_write_pass_float3(kg, buffer + kernel_data.film.pass_subsurface_indirect, sample, L->indirect_subsurface);
 	if(flag & PASS_DIFFUSE_DIRECT)
-		kernel_write_pass_float3(buffer + kernel_data.film.pass_diffuse_direct, sample, L->direct_diffuse);
+		kernel_write_pass_float3(kg, buffer + kernel_data.film.pass_diffuse_direct, sample, L->direct_diffuse);
 	if(flag & PASS_GLOSSY_DIRECT)
-		kernel_write_pass_float3(buffer + kernel_data.film.pass_glossy_direct, sample, L->direct_glossy);
+		kernel_write_pass_float3(kg, buffer + kernel_data.film.pass_glossy_direct, sample, L->direct_glossy);
 	if(flag & PASS_TRANSMISSION_DIRECT)
-		kernel_write_pass_float3(buffer + kernel_data.film.pass_transmission_direct, sample, L->direct_transmission);
+		kernel_write_pass_float3(kg, buffer + kernel_data.film.pass_transmission_direct, sample, L->direct_transmission);
 	if(flag & PASS_SUBSURFACE_DIRECT)
-		kernel_write_pass_float3(buffer + kernel_data.film.pass_subsurface_direct, sample, L->direct_subsurface);
+		kernel_write_pass_float3(kg, buffer + kernel_data.film.pass_subsurface_direct, sample, L->direct_subsurface);
 
 	if(flag & PASS_EMISSION)
-		kernel_write_pass_float3(buffer + kernel_data.film.pass_emission, sample, L->emission);
+		kernel_write_pass_float3(kg, buffer + kernel_data.film.pass_emission, sample, L->emission);
 	if(flag & PASS_BACKGROUND)
-		kernel_write_pass_float3(buffer + kernel_data.film.pass_background, sample, L->background);
+		kernel_write_pass_float3(kg, buffer + kernel_data.film.pass_background, sample, L->background);
 	if(flag & PASS_AO)
-		kernel_write_pass_float3(buffer + kernel_data.film.pass_ao, sample, L->ao);
+		kernel_write_pass_float3(kg, buffer + kernel_data.film.pass_ao, sample, L->ao);
 
 	if(flag & PASS_DIFFUSE_COLOR)
-		kernel_write_pass_float3(buffer + kernel_data.film.pass_diffuse_color, sample, L->color_diffuse);
+		kernel_write_pass_float3(kg, buffer + kernel_data.film.pass_diffuse_color, sample, L->color_diffuse);
 	if(flag & PASS_GLOSSY_COLOR)
-		kernel_write_pass_float3(buffer + kernel_data.film.pass_glossy_color, sample, L->color_glossy);
+		kernel_write_pass_float3(kg, buffer + kernel_data.film.pass_glossy_color, sample, L->color_glossy);
 	if(flag & PASS_TRANSMISSION_COLOR)
-		kernel_write_pass_float3(buffer + kernel_data.film.pass_transmission_color, sample, L->color_transmission);
+		kernel_write_pass_float3(kg, buffer + kernel_data.film.pass_transmission_color, sample, L->color_transmission);
 	if(flag & PASS_SUBSURFACE_COLOR)
-		kernel_write_pass_float3(buffer + kernel_data.film.pass_subsurface_color, sample, L->color_subsurface);
+		kernel_write_pass_float3(kg, buffer + kernel_data.film.pass_subsurface_color, sample, L->color_subsurface);
 	if(flag & PASS_SHADOW) {
 		float4 shadow = L->shadow;
 		shadow.w = kernel_data.film.pass_shadow_scale;
-		kernel_write_pass_float4(buffer + kernel_data.film.pass_shadow, sample, shadow);
+		kernel_write_pass_float4(kg, buffer + kernel_data.film.pass_shadow, sample, shadow);
 	}
 	if(flag & PASS_MIST)
-		kernel_write_pass_float(buffer + kernel_data.film.pass_mist, sample, 1.0f - L->mist);
+		kernel_write_pass_float(kg, buffer + kernel_data.film.pass_mist, sample, 1.0f - L->mist);
+#endif
+}
+
+ccl_device void kernel_write_result(KernelGlobals *kg, ccl_global float *buffer, int sample, float4 L)
+{
+#ifdef __ADAPTIVE__
+	float4 old_mean;
+	if((kernel_data.film.pass_flag & PASS_VARIANCE) && sample > 0)
+		old_mean = *((float4*) buffer) / sample;
+
+	kernel_write_pass_float4(kg, buffer, sample, L);
+
+	if(sample == 0 && (kernel_data.film.pass_flag & PASS_SAMPLES))
+		kernel_write_pass_float(kg, buffer + kernel_data.film.pass_samples, sample, 1.0f);
+
+	if(kernel_data.film.pass_flag & PASS_VARIANCE) {
+		if(sample == 0)
+			kernel_write_pass_float4(kg, buffer + kernel_data.film.pass_variance, sample, make_float4(0.0f, 0.0f, 0.0f, 0.0f));
+		else {
+			float4 new_mean = *((float4*) buffer) / (sample + 1);
+			kernel_write_pass_float4(kg, buffer + kernel_data.film.pass_variance, sample, (L - new_mean) * (L - old_mean));
+		}
+	}
+#else
+        kernel_write_pass_float4(kg, buffer, sample, L);
 #endif
 }
 
diff --git a/intern/cycles/kernel/kernel_path.h b/intern/cycles/kernel/kernel_path.h
index 151e762..5453bb0 100644
--- a/intern/cycles/kernel/kernel_path.h
+++ b/intern/cycles/kernel/kernel_path.h
@@ -474,6 +474,8 @@ ccl_device float4 kernel_path_integrate(KernelGlobals *kg, RNG *rng, int sample,
 	debug_data_init(&debug_data);
 #endif
 
+	float3 shadowcatcher = make_float3(0.0f, 0.0f, 0.0f);
+
 	/* path iteration */
 	for(;;) {
 		/* intersect scene */
@@ -658,6 +660,24 @@ ccl_device float4 kernel_path_integrate(KernelGlobals *kg, RNG *rng, int sample,
 		}
 #endif
 
+		if((sd.flag & SD_SHADOW_CATCHER)                     && (state.flag & PATH_RAY_CAMERA) &&
+		   (kernel_data.film.pass_flag & PASS_SHADOWCATCHER) && kernel_data.background.transparent) {
+			float shadow_catcher_weight = 1.0f;// average(shader_shadow_catcher_eval(kg, &sd));
+
+			PathRadiance L_shaded, L_full;
+			path_radiance_init(&L_shaded, false);
+			path_radiance_init(&L_full, false);
+
+			kernel_path_surface_connect_light(kg, rng, &sd, throughput, &state, &L_shaded, &L_full, false);
+
+			shadowcatcher += make_float3(shadow_catcher_weight*average(L_shaded.emission),
+						     shadow_catcher_weight*average(L_full.emission),
+						     shadow_catcher_weight*average(throughput));
+
+			if(shadow_catcher_weight == 1.0f)
+				break;
+		}
+
 		/* holdout mask objects do not write data passes */
 		kernel_write_data_passes(kg, buffer, &L, &sd, sample, &state, throughput);
 
@@ -726,6 +746,9 @@ ccl_device float4 kernel_path_integrate(KernelGlobals *kg, RNG *rng, int sample,
 
 	kernel_write_light_passes(kg, buffer, &L, sample);
 
+	if(kernel_data.film.pass_flag & PASS_SHADOWCATCHER)
+		kernel_write_pass_float3(kg, buffer + kernel_data.film.pass_shadowcatcher, sample, shadowcatcher);
+
 #ifdef __KERNEL_DEBUG__
 	kernel_write_debug_passes(kg, buffer, &state, &debug_data, sample);
 #endif
@@ -880,6 +903,8 @@ ccl_device float4 kernel_branched_path_integrate(KernelGlobals *kg, RNG *rng, in
 	debug_data_init(&debug_data);
 #endif
 
+	float3 shadowcatcher = make_float3(0.0f, 0.0f, 0.0f);
+
 	for(;;) {
 		/* intersect scene */
 		Intersection isect;
@@ -1076,6 +1101,24 @@ ccl_device float4 kernel_branched_path_integrate(KernelGlobals *kg, RNG *rng, in
 		}
 #endif
 
+		if((sd.flag & SD_SHADOW_CATCHER)                     && (state.flag & PATH_RAY_CAMERA) &&
+		   (kernel_data.film.pass_flag & PASS_SHADOWCATCHER) && kernel_data.background.transparent) {
+			float shadow_catcher_weight = 1.0f;//average(shader_shadow_catcher_eval(kg, &sd));
+
+			PathRadiance L_shaded, L_full;
+			path_radiance_init(&L_shaded, false);
+			path_radiance_init(&L_full, false);
+
+			kernel_path_surface_connect_light(kg, rng, &sd, throughput, &state, &L_shaded, &L_full, false);
+
+			shadowcatcher += make_float3(shadow_catcher_weight*average(L_shaded.emission),
+						     shadow_catcher_weight*average(L_full.emission),
+						     shadow_catcher_weight*average(throughput));
+
+			if(shadow_catcher_weight == 1.0f)
+				break;
+		}
+
 		/* holdout mask objects do not write data passes */
 		kernel_write_data_passes(kg, buffer, &L, &sd, sample, &state, throughput);
 
@@ -1166,6 +1209,9 @@ ccl_device float4 kernel_branched_path_integrate(KernelGlobals *kg, RNG *rng, in
 
 	kernel_write_light_passes(kg, buffer, &L, sample);
 
+	if(kernel_data.film.pass_flag & PASS_SHADOWCATCHER)
+		kernel_write_pass_float3(kg, buffer + kernel_data.film.pass_shadowcatcher, sample, shadowcatcher);
+
 #ifdef __KERNEL_DEBUG__
 	kernel_write_debug_passes(kg, buffer, &state, &debug_data, sample);
 #endif
@@ -1212,6 +1258,17 @@ ccl_device void kernel_path_trace(KernelGlobals *kg,
 	rng_state += index;
 	buffer += index*pass_stride;
 
+#ifdef __ADAPTIVE__
+	if(sample > 0 && (kernel_data.film.pass_flag & PASS_SAMPLES)) {
+#ifdef __KERNEL_GPU__
+		sample = (int) atomicAdd(buffer + kernel_data.film.pass_samples, 1.0f);
+#else
+		sample = (int) *(buffer + kernel_data.film.pass_samples);
+		*(buffer + kernel_data.film.pass_samples) += 1.0f;
+#endif
+	}
+#endif
+
 	/* initialize random numbers and ray */
 	RNG rng;
 	Ray ray;
@@ -1227,7 +1284,7 @@ ccl_device void kernel_path_trace(KernelGlobals *kg,
 		L = make_float4(0.0f, 0.0f, 0.0f, 0.0f);
 
 	/* accumulate result in output buffer */
-	kernel_write_pass_float4(buffer, sample, L);
+	kernel_write_result(kg, buffer, sample, L);
 
 	path_rng_end(kg, rng_state, rng);
 }
@@ -1244,6 +1301,17 @@ ccl_device void kernel_branched_path_trace(KernelGlobals *kg,
 	rng_state += index;
 	buffer += index*pass_stride;
 
+#ifdef __ADAPTIVE__
+	if(sample > 0 && (kernel_data.film.pass_flag & PASS_SAMPLES)) {
+#ifdef __KERNEL_GPU__
+		sample = (int) atomicAdd(buffer + kernel_data.film.pass_samples, 1.0f);
+#else
+		sample = (int) *(buffer + kernel_data.film.pass_samples);
+		*(buffer + kernel_data.film.pass_samples) += 1.0f;
+#endif
+	}
+#endif
+
 	/* initialize random numbers and ray */
 	RNG rng;
 	Ray ray;
@@ -1259,7 +1327,7 @@ ccl_device void kernel_branched_path_trace(KernelGlobals *kg,
 		L = make_float4(0.0f, 0.0f, 0.0f, 0.0f);
 
 	/* accumulate result in output buffer */
-	kernel_write_pass_float4(buffer, sample, L);
+	kernel_write_result(kg, buffer, sample, L);
 
 	path_rng_end(kg, rng_state, rng);
 }
diff --git a/intern/cycles/kernel/kernel_path_surface.h b/intern/cycles/kernel/kernel_path_surface.h
index f0d4e98..1256602 100644
--- a/intern/cycles/kernel/kernel_path_surface.h
+++ b/intern/cycles/kernel/kernel_path_surface.h
@@ -20,7 +20,7 @@ CCL_NAMESPACE_BEGIN
 
 /* branched path tracing: connect path directly to position on one or more lights and add it to L */
 ccl_device void kernel_branched_path_surface_connect_light(KernelGlobals *kg, RNG *rng,
-	ShaderData *sd, PathState *state, float3 throughput, float num_samples_adjust, PathRadiance *L, bool sample_all_lights)
+	ShaderData *sd, PathState *state, float3 throughput, float num_samples_adjust, PathRadiance *L, bool sample_all_lights, PathRadiance *L_no_occ = NULL, bool mis = true)
 {
 #ifdef __EMISSION__
 	/* sample illumination from lights to find path contribution */
@@ -55,6 +55,8 @@ ccl_device void kernel_branched_path_surface_connect_light(KernelGlobals *kg, RN
 				LightSample ls;
 				lamp_light_sample(kg, i, light_u, light_v, sd->P, &ls);
 
+				if (!mis)
+					ls.shader &= ~SHADER_USE_MIS;
 				if(direct_emission(kg, sd, &ls, &light_ray, &L_light, &is_lamp, state->bounce, state->transparent_bounce)) {
 					/* trace shadow ray */
 					float3 shadow;
@@ -63,6 +65,11 @@ ccl_device void kernel_branched_path_surface_connect_light(KernelGlobals *kg, RN
 						/* accumulate */
 						path_radiance_accum_light(L, throughput*num_samples_inv, &L_light, shadow, num_samples_inv, state->bounce, is_lamp);
 					}
+
+					if(L_no_occ) {
+						/* accumulate */
+						path_radiance_accum_light(L_no_occ, throughput*num_samples_inv, &L_light, make_float3(1, 1, 1), num_samples_inv, state->bounce, is_lamp);
+					}
 				}
 			}
 		}
@@ -95,6 +102,11 @@ ccl_device void kernel_branched_path_surface_connect_light(KernelGlobals *kg, RN
 						/* accumulate */
 						path_radiance_accum_light(L, throughput*num_samples_inv, &L_light, shadow, num_samples_inv, state->bounce, is_lamp);
 					}
+
+					if(L_no_occ) {
+						/* accumulate */
+						path_radiance_accum_light(L_no_occ, throughput*num_samples_inv, &L_light, make_float3(1, 1, 1), num_samples_inv, state->bounce, is_lamp);
+					}
 				}
 			}
 		}
@@ -117,6 +129,11 @@ ccl_device void kernel_branched_path_surface_connect_light(KernelGlobals *kg, RN
 				/* accumulate */
 				path_radiance_accum_light(L, throughput*num_samples_adjust, &L_light, shadow, num_samples_adjust, state->bounce, is_lamp);
 			}
+
+			if(L_no_occ) {
+				/* accumulate */
+				path_radiance_accum_light(L_no_occ, throughput*num_samples_adjust, &L_light, make_float3(1, 1, 1), num_samples_adjust, state->bounce, is_lamp);
+			}
 		}
 	}
 #endif
@@ -183,7 +200,7 @@ ccl_device bool kernel_branched_path_surface_bounce(KernelGlobals *kg, RNG *rng,
 
 /* path tracing: connect path directly to position on a light and add it to L */
 ccl_device_inline void kernel_path_surface_connect_light(KernelGlobals *kg, RNG *rng,
-	ShaderData *sd, float3 throughput, PathState *state, PathRadiance *L)
+	ShaderData *sd, float3 throughput, PathState *state, PathRadiance *L, PathRadiance *L_unoccluded = NULL, bool mis = true)
 {
 #ifdef __EMISSION__
 	if(!(kernel_data.integrator.use_direct_light && (sd->flag & SD_BSDF_HAS_EVAL)))
@@ -204,7 +221,8 @@ ccl_device_inline void kernel_path_surface_connect_light(KernelGlobals *kg, RNG
 
 	LightSample ls;
 	light_sample(kg, light_t, light_u, light_v, sd->time, sd->P, state->bounce, &ls);
-
+	if (!mis)
+		ls.shader &= ~SHADER_USE_MIS;
 	if(direct_emission(kg, sd, &ls, &light_ray, &L_light, &is_lamp, state->bounce, state->transparent_bounce)) {
 		/* trace shadow ray */
 		float3 shadow;
@@ -213,6 +231,12 @@ ccl_device_inline void kernel_path_surface_connect_light(KernelGlobals *kg, RNG
 			/* accumulate */
 			path_radiance_accum_light(L, throughput, &L_light, shadow, 1.0f, state->bounce, is_lamp);
 		}
+
+		if(L_unoccluded) {
+			/* accumulate */
+			path_radiance_accum_light(L_unoccluded, throughput, &L_light, make_float3(1.0f, 1.0f, 1.0f), 1.0f, state->bounce, is_lamp);
+		}
+
 	}
 #endif
 }
diff --git a/intern/cycles/kernel/kernel_shader.h b/intern/cycles/kernel/kernel_shader.h
index c6bf12d..b625856 100644
--- a/intern/cycles/kernel/kernel_shader.h
+++ b/intern/cycles/kernel/kernel_shader.h
@@ -781,6 +781,22 @@ ccl_device float3 shader_holdout_eval(KernelGlobals *kg, ShaderData *sd)
 	return weight;
 }
 
+/* Shadow Catcher */
+
+ccl_device float3 shader_shadow_catcher_eval(KernelGlobals *kg, ShaderData *sd)
+{
+	float3 weight = make_float3(0.0f, 0.0f, 0.0f);
+
+	for(int i = 0; i < sd->num_closure; i++) {
+		ShaderClosure *sc = &sd->closure[i];
+
+		if(CLOSURE_IS_SHADOWCATCHER(sc->type))
+			weight += sc->weight;
+	}
+
+	return weight;
+}
+
 /* Surface Evaluation */
 
 ccl_device void shader_eval_surface(KernelGlobals *kg, ShaderData *sd,
diff --git a/intern/cycles/kernel/kernel_types.h b/intern/cycles/kernel/kernel_types.h
index 238b4b0..d981344 100644
--- a/intern/cycles/kernel/kernel_types.h
+++ b/intern/cycles/kernel/kernel_types.h
@@ -72,6 +72,7 @@ CCL_NAMESPACE_BEGIN
 #define __VOLUME_DECOUPLED__
 #define __VOLUME_SCATTER__
 #define __SHADOW_RECORD_ALL__
+#define __ADAPTIVE__
 #endif
 
 #ifdef __KERNEL_CUDA__
@@ -85,6 +86,7 @@ CCL_NAMESPACE_BEGIN
 #ifdef __KERNEL_CUDA_EXPERIMENTAL__
 #define __SUBSURFACE__
 #define __CMJ__
+#define __ADAPTIVE__
 #endif
 
 #endif
@@ -320,9 +322,13 @@ typedef enum PassType {
 	PASS_SUBSURFACE_INDIRECT = (1 << 23),
 	PASS_SUBSURFACE_COLOR = (1 << 24),
 	PASS_LIGHT = (1 << 25), /* no real pass, used to force use_light_pass */
+	PASS_SAMPLES = (1 << 26),
+	PASS_VARIANCE = (1 << 27),
 #ifdef __KERNEL_DEBUG__
-	PASS_BVH_TRAVERSAL_STEPS = (1 << 26),
+	PASS_BVH_TRAVERSAL_STEPS = (1 << 28),
+	PASS_IMPORTANCE = (1 << 29),
 #endif
+	PASS_SHADOWCATCHER = (1 << 30),
 } PassType;
 
 #define PASS_ALL (~0)
@@ -601,9 +607,10 @@ enum ShaderDataFlag {
 	SD_SCATTER        = (1 << 7),   /* have volume phase closure? */
 	SD_AO             = (1 << 8),   /* have ao closure? */
 	SD_TRANSPARENT    = (1 << 9),  /* have transparent closure? */
+	SD_SHADOW_CATCHER = (1 << 27),
 
 	SD_CLOSURE_FLAGS = (SD_EMISSION|SD_BSDF|SD_BSDF_HAS_EVAL|SD_BSSRDF|
-	                    SD_HOLDOUT|SD_ABSORPTION|SD_SCATTER|SD_AO),
+	                    SD_HOLDOUT|SD_ABSORPTION|SD_SCATTER|SD_AO|SD_SHADOW_CATCHER),
 
 	/* shader flags */
 	SD_USE_MIS                = (1 << 10),  /* direct light sample */
@@ -858,17 +865,21 @@ typedef struct KernelFilm {
 	int pass_shadow;
 	float pass_shadow_scale;
 	int filter_table_offset;
-	int pass_pad2;
+	int pass_samples;
 
+	int pass_variance;
 	int pass_mist;
-	float mist_start;
-	float mist_inv_depth;
-	float mist_falloff;
-
 #ifdef __KERNEL_DEBUG__
 	int pass_bvh_traversal_steps;
-	int pass_pad3, pass_pad4, pass_pad5;
+#else
+	int pass_pad0;
 #endif
+	int pass_shadowcatcher;
+
+	int use_atomics;
+	float mist_start;
+	float mist_inv_depth;
+	float mist_falloff;
 } KernelFilm;
 
 typedef struct KernelBackground {
@@ -895,6 +906,11 @@ typedef struct KernelIntegrator {
 	float inv_pdf_lights;
 	int pdf_background_res;
 
+	/* light portals */
+	float portal_pdf;
+	int num_portals;
+	int portal_offset;
+
 	/* bounces */
 	int min_bounce;
 	int max_bounce;
diff --git a/intern/cycles/kernel/osl/background.cpp b/intern/cycles/kernel/osl/background.cpp
index 2facced..5eb19fc 100644
--- a/intern/cycles/kernel/osl/background.cpp
+++ b/intern/cycles/kernel/osl/background.cpp
@@ -63,6 +63,18 @@ public:
 	HoldoutClosure () : CClosurePrimitive(Holdout) {}
 };
 
+/// Shadow catcher closure
+///
+/// This will be used by the shader to mark the
+/// weight of the shadow catcher for the current shading
+/// point. No parameters, only the weight will be
+/// used
+///
+class ShadowCatcherClosure : CClosurePrimitive {
+public:
+	ShadowCatcherClosure () : CClosurePrimitive(ShadowCatcher) {}
+};
+
 /// ambient occlusion closure
 ///
 /// We only have a ambient occlusion closure for the shaders
@@ -88,13 +100,23 @@ CCLOSURE_PREPARE(closure_background_prepare, GenericBackgroundClosure)
 ClosureParam *closure_holdout_params()
 {
 	static ClosureParam params[] = {
-	    CLOSURE_FINISH_PARAM(HoldoutClosure)
+		CLOSURE_FINISH_PARAM(HoldoutClosure)
 	};
 	return params;
 }
 
 CCLOSURE_PREPARE(closure_holdout_prepare, HoldoutClosure)
 
+ClosureParam *closure_shadow_catcher_params()
+{
+	static ClosureParam params[] = {
+		CLOSURE_FINISH_PARAM(ShadowCatcherClosure)
+	};
+	return params;
+}
+
+CCLOSURE_PREPARE(closure_shadow_catcher_prepare, ShadowCatcherClosure)
+
 ClosureParam *closure_ambient_occlusion_params()
 {
 	static ClosureParam params[] = {
diff --git a/intern/cycles/kernel/osl/osl_closures.cpp b/intern/cycles/kernel/osl/osl_closures.cpp
index 461ce8f..0ecd264 100644
--- a/intern/cycles/kernel/osl/osl_closures.cpp
+++ b/intern/cycles/kernel/osl/osl_closures.cpp
@@ -226,6 +226,8 @@ void OSLShader::register_closures(OSLShadingSystem *ss_)
 		closure_background_params(), closure_background_prepare);
 	register_closure(ss, "holdout", id++,
 		closure_holdout_params(), closure_holdout_prepare);
+	register_closure(ss, "shadow_catcher", id++,
+		closure_shadow_catcher_params(), closure_shadow_catcher_prepare);
 	register_closure(ss, "ambient_occlusion", id++,
 		closure_ambient_occlusion_params(), closure_ambient_occlusion_prepare);
 	register_closure(ss, "diffuse_ramp", id++,
diff --git a/intern/cycles/kernel/osl/osl_closures.h b/intern/cycles/kernel/osl/osl_closures.h
index 5e833d7..49c32a1 100644
--- a/intern/cycles/kernel/osl/osl_closures.h
+++ b/intern/cycles/kernel/osl/osl_closures.h
@@ -45,6 +45,7 @@ CCL_NAMESPACE_BEGIN
 OSL::ClosureParam *closure_emission_params();
 OSL::ClosureParam *closure_background_params();
 OSL::ClosureParam *closure_holdout_params();
+OSL::ClosureParam *closure_shadow_catcher_params();
 OSL::ClosureParam *closure_ambient_occlusion_params();
 OSL::ClosureParam *closure_bsdf_diffuse_ramp_params();
 OSL::ClosureParam *closure_bsdf_phong_ramp_params();
@@ -55,6 +56,7 @@ OSL::ClosureParam *closure_henyey_greenstein_volume_params();
 void closure_emission_prepare(OSL::RendererServices *, int id, void *data);
 void closure_background_prepare(OSL::RendererServices *, int id, void *data);
 void closure_holdout_prepare(OSL::RendererServices *, int id, void *data);
+void closure_shadow_catcher_prepare(OSL::RendererServices *, int id, void *data);
 void closure_ambient_occlusion_prepare(OSL::RendererServices *, int id, void *data);
 void closure_bsdf_diffuse_ramp_prepare(OSL::RendererServices *, int id, void *data);
 void closure_bsdf_phong_ramp_prepare(OSL::RendererServices *, int id, void *data);
@@ -89,6 +91,7 @@ public:
 		Background,       ///< Background emission
 		Volume,           ///< Volume scattering
 		Holdout,          ///< Holdout from alpha
+		ShadowCatcher,    ///< Shadow Catcher from alpha
 		AmbientOcclusion, ///< Ambient occlusion
 	};
 
diff --git a/intern/cycles/kernel/osl/osl_shader.cpp b/intern/cycles/kernel/osl/osl_shader.cpp
index fa6745a..0d76b61 100644
--- a/intern/cycles/kernel/osl/osl_shader.cpp
+++ b/intern/cycles/kernel/osl/osl_shader.cpp
@@ -244,6 +244,20 @@ static void flatten_surface_closure_tree(ShaderData *sd, int path_flag,
 					}
 					break;
 				}
+				case CClosurePrimitive::ShadowCatcher: {
+					sc.sample_weight = 0.0f;
+					sc.type = CLOSURE_SHADOWCATCHER_ID;
+					sc.data0 = 0.0f;
+					sc.data1 = 0.0f;
+					sc.data2 = 0.0f;
+					sc.prim = NULL;
+
+					if(sd->num_closure < MAX_CLOSURE) {
+						sd->closure[sd->num_closure++] = sc;
+						sd->flag |= SD_SHADOW_CATCHER;
+					}
+					break;
+				}
 				case CClosurePrimitive::BSSRDF: {
 					CBSSRDFClosure *bssrdf = (CBSSRDFClosure *)prim;
 					float sample_weight = fabsf(average(weight));
diff --git a/intern/cycles/kernel/shaders/stdosl.h b/intern/cycles/kernel/shaders/stdosl.h
index 6babe98..76295c9 100644
--- a/intern/cycles/kernel/shaders/stdosl.h
+++ b/intern/cycles/kernel/shaders/stdosl.h
@@ -491,6 +491,7 @@ closure color ashikhmin_velvet(normal N, float sigma) BUILTIN;
 closure color emission() BUILTIN;
 closure color background() BUILTIN;
 closure color holdout() BUILTIN;
+closure color shadow_catcher() BUILTIN;
 closure color ambient_occlusion() BUILTIN;
 
 // BSSRDF
diff --git a/intern/cycles/kernel/svm/svm.h b/intern/cycles/kernel/svm/svm.h
index d59c9b9..d8ab06b 100644
--- a/intern/cycles/kernel/svm/svm.h
+++ b/intern/cycles/kernel/svm/svm.h
@@ -211,6 +211,9 @@ ccl_device_noinline void svm_eval_nodes(KernelGlobals *kg, ShaderData *sd, Shade
 			case NODE_CLOSURE_HOLDOUT:
 				svm_node_closure_holdout(sd, stack, node);
 				break;
+			case NODE_CLOSURE_SHADOW_CATCHER:
+				svm_node_closure_shadow_catcher(sd, stack, node);
+				break;
 			case NODE_CLOSURE_AMBIENT_OCCLUSION:
 				svm_node_closure_ambient_occlusion(sd, stack, node);
 				break;
diff --git a/intern/cycles/kernel/svm/svm_closure.h b/intern/cycles/kernel/svm/svm_closure.h
index db9f442..44919aa 100644
--- a/intern/cycles/kernel/svm/svm_closure.h
+++ b/intern/cycles/kernel/svm/svm_closure.h
@@ -597,6 +597,28 @@ ccl_device void svm_node_closure_holdout(ShaderData *sd, float *stack, uint4 nod
 	sd->flag |= SD_HOLDOUT;
 }
 
+ccl_device void svm_node_closure_shadow_catcher(ShaderData *sd, float *stack, uint4 node)
+{
+	uint mix_weight_offset = node.y;
+
+	float mix_weight = stack_valid(mix_weight_offset)? stack_load_float(stack, mix_weight_offset): 1.0f;
+
+	if(mix_weight == 0.0f)
+		return;
+
+	ShaderClosure *sc = svm_node_closure_get_bsdf(sd, mix_weight);
+
+	if (sc) {
+		sc->N = sd->N;
+		sc->data0 = 0.0f;
+		sc->data1 = 0.0f;
+		sc->data2 = 0.0f;
+		sd->flag |= bsdf_diffuse_setup(sc);
+	}
+
+	sd->flag |= SD_SHADOW_CATCHER;
+}
+
 ccl_device void svm_node_closure_ambient_occlusion(ShaderData *sd, float *stack, uint4 node)
 {
 	uint mix_weight_offset = node.y;
diff --git a/intern/cycles/kernel/svm/svm_types.h b/intern/cycles/kernel/svm/svm_types.h
index 7130b14..f181c6d 100644
--- a/intern/cycles/kernel/svm/svm_types.h
+++ b/intern/cycles/kernel/svm/svm_types.h
@@ -76,6 +76,7 @@ typedef enum NodeType {
 	NODE_ATTR_BUMP_DY,
 	NODE_TEX_ENVIRONMENT,
 	NODE_CLOSURE_HOLDOUT,
+	NODE_CLOSURE_SHADOW_CATCHER,
 	NODE_LAYER_WEIGHT,
 	NODE_CLOSURE_VOLUME,
 	NODE_SEPARATE_VECTOR,
@@ -401,6 +402,7 @@ typedef enum ClosureType {
 	CLOSURE_EMISSION_ID,
 	CLOSURE_BACKGROUND_ID,
 	CLOSURE_HOLDOUT_ID,
+	CLOSURE_SHADOWCATCHER_ID,
 	CLOSURE_AMBIENT_OCCLUSION_ID,
 
 	/* Volume */
@@ -423,6 +425,7 @@ typedef enum ClosureType {
 #define CLOSURE_IS_VOLUME(type) (type >= CLOSURE_VOLUME_ID && type <= CLOSURE_VOLUME_HENYEY_GREENSTEIN_ID)
 #define CLOSURE_IS_EMISSION(type) (type == CLOSURE_EMISSION_ID)
 #define CLOSURE_IS_HOLDOUT(type) (type == CLOSURE_HOLDOUT_ID)
+#define CLOSURE_IS_SHADOWCATCHER(type) (type == CLOSURE_SHADOWCATCHER_ID)
 #define CLOSURE_IS_BACKGROUND(type) (type == CLOSURE_BACKGROUND_ID)
 #define CLOSURE_IS_AMBIENT_OCCLUSION(type) (type == CLOSURE_AMBIENT_OCCLUSION_ID)
 #define CLOSURE_IS_PHASE(type) (type == CLOSURE_VOLUME_HENYEY_GREENSTEIN_ID)
diff --git a/intern/cycles/render/buffers.cpp b/intern/cycles/render/buffers.cpp
index 5202bf5..d116cff 100644
--- a/intern/cycles/render/buffers.cpp
+++ b/intern/cycles/render/buffers.cpp
@@ -19,10 +19,12 @@
 #include "buffers.h"
 #include "device.h"
 
+#include "util_color.h"
 #include "util_debug.h"
 #include "util_foreach.h"
 #include "util_hash.h"
 #include "util_image.h"
+#include "util_importance.h"
 #include "util_math.h"
 #include "util_opengl.h"
 #include "util_time.h"
@@ -118,6 +120,8 @@ void RenderBuffers::device_free()
 		device->mem_free(rng_state);
 		rng_state.clear();
 	}
+
+	importance_map.clear();
 }
 
 void RenderBuffers::reset(Device *device, BufferParams& params_)
@@ -138,12 +142,20 @@ void RenderBuffers::reset(Device *device, BufferParams& params_)
 	uint *init_state = rng_state.resize(params.width, params.height);
 	int x, y, width = params.width, height = params.height;
 	
-	for(x = 0; x < width; x++)
-		for(y = 0; y < height; y++)
+	for(y = 0; y < height; y++)
+		for(x = 0; x < width; x++)
 			init_state[x + y*width] = hash_int_2d(params.full_x+x, params.full_y+y);
 
 	device->mem_alloc(rng_state, MEM_READ_WRITE);
 	device->mem_copy_to(rng_state);
+
+	/* allocate importance map */
+	if(params.use_importance) {
+		importance_map.resize(width * height);
+		for(y = 0; y < height; y++)
+			for(x = 0; x < width; x++)
+				importance_map[y*width + x] = 1.0f;
+	}
 }
 
 bool RenderBuffers::copy_from_device()
@@ -156,9 +168,34 @@ bool RenderBuffers::copy_from_device()
 	return true;
 }
 
+inline float RenderBuffers::get_sample_scale(const Pass &pass, float *pixel, int samples_pass, float scale, float exposure)
+{
+	if(samples_pass < 0)
+		return scale * exposure;
+	if(!pass.filter)
+		return exposure;
+	float sample_pass = *(pixel + samples_pass);
+	if(sample_pass == 0.0f)
+		return 0.0f;
+	return exposure / sample_pass;
+}
+
 bool RenderBuffers::get_pass_rect(PassType type, float exposure, int sample, int components, float *pixels)
 {
 	int pass_offset = 0;
+	int samples_pass = 0;
+	bool has_samples_pass = false;
+
+	foreach(Pass& pass, params.passes) {
+		if(pass.type == PASS_SAMPLES) {
+			has_samples_pass = true;
+			break;
+		}
+		samples_pass += pass.components;
+	}
+
+	if(!has_samples_pass)
+		samples_pass = -1;
 
 	foreach(Pass& pass, params.passes) {
 		if(pass.type != type) {
@@ -170,24 +207,28 @@ bool RenderBuffers::get_pass_rect(PassType type, float exposure, int sample, int
 		int pass_stride = params.get_passes_size();
 
 		float scale = (pass.filter)? 1.0f/(float)sample: 1.0f;
-		float scale_exposure = (pass.exposure)? scale*exposure: scale;
+		float pass_exposure = (pass.exposure)? exposure: 1.0f;
 
 		int size = params.width*params.height;
 
 		if(components == 1) {
+			if (pass.components != components)
+				printf("FAIL!\n");
 			assert(pass.components == components);
 
 			/* scalar */
 			if(type == PASS_DEPTH) {
 				for(int i = 0; i < size; i++, in += pass_stride, pixels++) {
 					float f = *in;
-					pixels[0] = (f == 0.0f)? 1e10f: f*scale_exposure;
+					float fac = get_sample_scale(pass, in - pass_offset, samples_pass, scale, pass_exposure);
+					pixels[0] = (f == 0.0f)? 1e10f: f*fac;
 				}
 			}
 			else if(type == PASS_MIST) {
 				for(int i = 0; i < size; i++, in += pass_stride, pixels++) {
 					float f = *in;
-					pixels[0] = clamp(f*scale_exposure, 0.0f, 1.0f);
+					float fac = get_sample_scale(pass, in - pass_offset, samples_pass, scale, pass_exposure);
+					pixels[0] = clamp(f*fac, 0.0f, 1.0f);
 				}
 			}
 #ifdef WITH_CYCLES_DEBUG
@@ -197,11 +238,23 @@ bool RenderBuffers::get_pass_rect(PassType type, float exposure, int sample, int
 					pixels[0] = f;
 				}
 			}
+			else if(type == PASS_SAMPLES) {
+				for(int i = 0; i < size; i++, in += pass_stride, pixels++) {
+					float f = *in;
+					pixels[0] = f;
+				}
+			}
+			else if(type == PASS_IMPORTANCE) {
+				for(int i = 0; i < size; i++, in += pass_stride, pixels++) {
+					pixels[0] = params.use_importance? importance_map[i]: 1.0f;
+				}
+			}
 #endif
 			else {
 				for(int i = 0; i < size; i++, in += pass_stride, pixels++) {
 					float f = *in;
-					pixels[0] = f*scale_exposure;
+					float fac = get_sample_scale(pass, in - pass_offset, samples_pass, scale, pass_exposure);
+					pixels[0] = f*fac;
 				}
 			}
 		}
@@ -245,10 +298,11 @@ bool RenderBuffers::get_pass_rect(PassType type, float exposure, int sample, int
 				/* RGB/vector */
 				for(int i = 0; i < size; i++, in += pass_stride, pixels += 3) {
 					float3 f = make_float3(in[0], in[1], in[2]);
+					float fac = get_sample_scale(pass, in - pass_offset, samples_pass, scale, pass_exposure);
 
-					pixels[0] = f.x*scale_exposure;
-					pixels[1] = f.y*scale_exposure;
-					pixels[2] = f.z*scale_exposure;
+					pixels[0] = f.x*fac;
+					pixels[1] = f.y*fac;
+					pixels[2] = f.z*fac;
 				}
 			}
 		}
@@ -289,16 +343,53 @@ bool RenderBuffers::get_pass_rect(PassType type, float exposure, int sample, int
 					pixels[3] = f.w*invw;
 				}
 			}
-			else {
+#ifdef WITH_CYCLES_DEBUG
+			else if(type == PASS_VARIANCE) {
 				for(int i = 0; i < size; i++, in += pass_stride, pixels += 4) {
 					float4 f = make_float4(in[0], in[1], in[2], in[3]);
+					float fac = get_sample_scale(pass, in - pass_offset, samples_pass, scale, 1.0f);
 
-					pixels[0] = f.x*scale_exposure;
-					pixels[1] = f.y*scale_exposure;
-					pixels[2] = f.z*scale_exposure;
-
+					pixels[0] = f.x*fac;
+					pixels[1] = f.y*fac;
+					pixels[2] = f.z*fac;
+					pixels[3] = 1.0f;
+				}
+			}
+#endif
+			else {
+				int shadowcatcher_offset = 0;
+				bool found_shadowcatcher = false;
+				foreach(Pass& pass, params.passes) {
+					if(pass.type != PASS_SHADOWCATCHER)
+						shadowcatcher_offset += pass.components;
+					else {
+						found_shadowcatcher = true;
+						break;
+					}
+				}
+				
+				for(int i = 0; i < size; i++, in += pass_stride, pixels += 4) {
+					float4 f = make_float4(in[0], in[1], in[2], in[3]);
+					float fac = get_sample_scale(pass, in - pass_offset, samples_pass, scale, pass_exposure);
+
+					pixels[0] = f.x*fac;
+					pixels[1] = f.y*fac;
+					pixels[2] = f.z*fac;
+
+					fac = get_sample_scale(pass, in - pass_offset, samples_pass, scale, 1.0f);
+					float pixel_alpha = f.w*fac;
+					if (found_shadowcatcher) {
+						float3 shadowcatcher_val = *((float3*) (in - pass_offset + shadowcatcher_offset));
+						float L_shaded = shadowcatcher_val.x, L_full = shadowcatcher_val.y, L_fac = shadowcatcher_val.z*fac;
+						if (L_fac > 0.0f) {
+							if (L_full > 0.0f)
+								pixel_alpha = (1.0f - L_shaded / L_full) * L_fac + (1.0f - L_fac) * pixel_alpha;
+							else
+								pixel_alpha = (1.0f - L_fac) * pixel_alpha;
+						}
+					}
 					/* clamp since alpha might be > 1.0 due to russian roulette */
-					pixels[3] = clamp(f.w*scale, 0.0f, 1.0f);
+					pixels[3] = clamp(pixel_alpha, 0.0f, 1.0f);
 				}
 			}
 		}
diff --git a/intern/cycles/render/buffers.h b/intern/cycles/render/buffers.h
index 4fa1c51..2ba2d50 100644
--- a/intern/cycles/render/buffers.h
+++ b/intern/cycles/render/buffers.h
@@ -49,6 +49,8 @@ public:
 	int full_width;
 	int full_height;
 
+	bool use_importance;
+
 	/* passes */
 	vector<Pass> passes;
 
@@ -72,6 +74,8 @@ public:
 	device_vector<float> buffer;
 	/* random number generator state */
 	device_vector<uint> rng_state;
+	/* importance map */
+	vector<float> importance_map;
 
 	RenderBuffers(Device *device);
 	~RenderBuffers();
@@ -83,6 +87,7 @@ public:
 
 protected:
 	void device_free();
+	inline float get_sample_scale(const Pass &pass, float *pixel, int samples_pass, float scale, float exposure);
 
 	Device *device;
 };
@@ -142,6 +147,12 @@ public:
 	device_ptr buffer;
 	device_ptr rng_state;
 
+	/* For restoring the Tile in error-progressive mode */
+	int t_index;
+	int t_x, t_y;
+	int t_device;
+	float t_priority;
+
 	RenderBuffers *buffers;
 
 	RenderTile();
diff --git a/intern/cycles/render/film.cpp b/intern/cycles/render/film.cpp
index c6d1292..6c26859 100644
--- a/intern/cycles/render/film.cpp
+++ b/intern/cycles/render/film.cpp
@@ -151,7 +151,23 @@ void Pass::add(PassType type, vector<Pass>& passes)
 			pass.components = 1;
 			pass.exposure = false;
 			break;
+		case PASS_IMPORTANCE:
+			pass.components = 1;
+			pass.exposure = false;
+			break;
 #endif
+		case PASS_SAMPLES:
+			pass.components = 1;
+			pass.exposure = false;
+			break;
+		case PASS_VARIANCE:
+			pass.components = 4;
+			pass.exposure = false;
+			break;
+		case PASS_SHADOWCATCHER:
+			pass.components = 3;
+			pass.exposure = false;
+			break;
 	}
 
 	passes.push_back(pass);
@@ -399,8 +415,24 @@ void Film::device_update(Device *device, DeviceScene *dscene, Scene *scene)
 			case PASS_BVH_TRAVERSAL_STEPS:
 				kfilm->pass_bvh_traversal_steps = kfilm->pass_stride;
 				break;
+
+			case PASS_IMPORTANCE:
+				/* no kernel involvement for this pass */
+				break;
 #endif
 
+			case PASS_SAMPLES:
+				kfilm->pass_samples = kfilm->pass_stride;
+				break;
+
+			case PASS_VARIANCE:
+				kfilm->pass_variance = kfilm->pass_stride;
+				break;
+
+			case PASS_SHADOWCATCHER:
+				kfilm->pass_shadowcatcher = kfilm->pass_stride;
+				break;
+
 			case PASS_NONE:
 				break;
 		}
@@ -421,6 +453,15 @@ void Film::device_update(Device *device, DeviceScene *dscene, Scene *scene)
 	kfilm->mist_inv_depth = (mist_depth > 0.0f)? 1.0f/mist_depth: 0.0f;
 	kfilm->mist_falloff = mist_falloff;
 
+	/* use atomics? */
+	kfilm->use_atomics = false;
+	foreach(Pass& pass, passes) {
+		if(pass.type == PASS_SAMPLES) {
+			kfilm->use_atomics = true;
+			break;
+		}
+	}
+
 	need_update = false;
 }
 
diff --git a/intern/cycles/render/light.cpp b/intern/cycles/render/light.cpp
index 284012e..a7adf98 100644
--- a/intern/cycles/render/light.cpp
+++ b/intern/cycles/render/light.cpp
@@ -128,6 +128,8 @@ Light::Light()
 	shader = 0;
 	samples = 1;
 	max_bounces = 1024;
+
+	portal = false;
 }
 
 void Light::tag_update(Scene *scene)
@@ -152,10 +154,16 @@ void LightManager::device_update_distribution(Device *device, DeviceScene *dscen
 	progress.set_status("Updating Lights", "Computing distribution");
 
 	/* count */
-	size_t num_lights = scene->lights.size();
+	size_t num_lights = 0;
 	size_t num_background_lights = 0;
+	bool background_mis = false;
 	size_t num_triangles = 0;
 
+	foreach(Light *light, scene->lights) {
+		if (!light->portal)
+			num_lights++;
+	}
+
 	foreach(Object *object, scene->objects) {
 		Mesh *mesh = object->mesh;
 		bool have_emission = false;
@@ -286,22 +294,28 @@ void LightManager::device_update_distribution(Device *device, DeviceScene *dscen
 	float trianglearea = totarea;
 
 	/* point lights */
-	float lightarea = (totarea > 0.0f)? totarea/scene->lights.size(): 1.0f;
+	float lightarea = (totarea > 0.0f) ? totarea / num_lights : 1.0f;
 	bool use_lamp_mis = false;
 
-	for(int i = 0; i < scene->lights.size(); i++, offset++) {
-		Light *light = scene->lights[i];
+	int pos = 0;
+	foreach(Light *light, scene->lights) {
+		if (light->portal) continue;
 
 		distribution[offset].x = totarea;
-		distribution[offset].y = __int_as_float(~(int)i);
+		distribution[offset].y = __int_as_float(~(int)pos);
 		distribution[offset].z = 1.0f;
 		distribution[offset].w = light->size;
 		totarea += lightarea;
 
 		if(light->size > 0.0f && light->use_mis)
 			use_lamp_mis = true;
-		if(light->type == LIGHT_BACKGROUND)
+		if (light->type == LIGHT_BACKGROUND) {
 			num_background_lights++;
+			background_mis = light->use_mis;
+		}
+
+		pos++;
+		offset++;
 	}
 
 	/* normalize cumulative distribution functions */
@@ -363,6 +377,17 @@ void LightManager::device_update_distribution(Device *device, DeviceScene *dscen
 
 		/* CDF */
 		device->tex_alloc("__light_distribution", dscene->light_distribution);
+
+		if (num_background_lights > 0 && pos != scene->lights.size()) {
+			kintegrator->portal_offset = pos;
+			kintegrator->num_portals = scene->lights.size() - pos;
+			kintegrator->portal_pdf = background_mis? 0.5f: 1.0f;
+		}
+		else {
+			kintegrator->num_portals = 0;
+			kintegrator->portal_offset = 0;
+			kintegrator->portal_pdf = 0.0f;
+		}
 	}
 	else {
 		dscene->light_distribution.clear();
@@ -374,6 +399,9 @@ void LightManager::device_update_distribution(Device *device, DeviceScene *dscen
 		kintegrator->inv_pdf_lights = 0.0f;
 		kintegrator->use_lamp_mis = false;
 		kfilm->pass_shadow_scale = 1.0f;
+		kintegrator->num_portals = 0;
+		kintegrator->portal_offset = 0;
+		kintegrator->portal_pdf = 0.0f;
 	}
 }
 
@@ -472,25 +500,34 @@ void LightManager::device_update_background(Device *device, DeviceScene *dscene,
 
 void LightManager::device_update_points(Device *device, DeviceScene *dscene, Scene *scene)
 {
+	bool has_portals = false;
+	foreach(Light *light, scene->lights) {
+		if (light->portal) {
+			has_portals = true;
+			break;
+		}
+	}
+
+	/* remove background light? */
+	foreach(Light *light, scene->lights) {
+		if (light->type != LIGHT_BACKGROUND) continue;
+		if (!(device->info.advanced_shading && (has_portals || light->use_mis)))
+			scene->lights.erase(std::remove(scene->lights.begin(), scene->lights.end(), light), scene->lights.end());
+		break;
+	}
+
 	if(scene->lights.size() == 0)
 		return;
 
 	float4 *light_data = dscene->light_data.resize(scene->lights.size()*LIGHT_SIZE);
 
-	if(!device->info.advanced_shading) {
-		/* remove unsupported light */
-		foreach(Light *light, scene->lights) {
-			if(light->type == LIGHT_BACKGROUND) {
-				scene->lights.erase(std::remove(scene->lights.begin(), scene->lights.end(), light), scene->lights.end());
-				break;
-			}
-		}
-	}
+	int pos = 0;
+
+	foreach(Light *light, scene->lights) {
+		if (light->portal) continue;
 
-	for(size_t i = 0; i < scene->lights.size(); i++) {
-		Light *light = scene->lights[i];
 		float3 co = light->co;
-		int shader_id = scene->shader_manager->get_shader_id(scene->lights[i]->shader);
+		int shader_id = scene->shader_manager->get_shader_id(light->shader);
 		float samples = __int_as_float(light->samples);
 		float max_bounces = __int_as_float(light->max_bounces);
 
@@ -523,11 +560,11 @@ void LightManager::device_update_points(Device *device, DeviceScene *dscene, Sce
 			if(light->use_mis && radius > 0.0f)
 				shader_id |= SHADER_USE_MIS;
 
-			light_data[i*LIGHT_SIZE + 0] = make_float4(__int_as_float(light->type), co.x, co.y, co.z);
-			light_data[i*LIGHT_SIZE + 1] = make_float4(__int_as_float(shader_id), radius, invarea, 0.0f);
-			light_data[i*LIGHT_SIZE + 2] = make_float4(0.0f, 0.0f, 0.0f, 0.0f);
-			light_data[i*LIGHT_SIZE + 3] = make_float4(samples, 0.0f, 0.0f, 0.0f);
-			light_data[i*LIGHT_SIZE + 4] = make_float4(max_bounces, 0.0f, 0.0f, 0.0f);
+			light_data[pos*LIGHT_SIZE + 0] = make_float4(__int_as_float(light->type), co.x, co.y, co.z);
+			light_data[pos*LIGHT_SIZE + 1] = make_float4(__int_as_float(shader_id), radius, invarea, 0.0f);
+			light_data[pos*LIGHT_SIZE + 2] = make_float4(0.0f, 0.0f, 0.0f, 0.0f);
+			light_data[pos*LIGHT_SIZE + 3] = make_float4(samples, 0.0f, 0.0f, 0.0f);
+			light_data[pos*LIGHT_SIZE + 4] = make_float4(max_bounces, 0.0f, 0.0f, 0.0f);
 		}
 		else if(light->type == LIGHT_DISTANT) {
 			shader_id &= ~SHADER_AREA_LIGHT;
@@ -544,11 +581,11 @@ void LightManager::device_update_points(Device *device, DeviceScene *dscene, Sce
 			if(light->use_mis && area > 0.0f)
 				shader_id |= SHADER_USE_MIS;
 
-			light_data[i*LIGHT_SIZE + 0] = make_float4(__int_as_float(light->type), dir.x, dir.y, dir.z);
-			light_data[i*LIGHT_SIZE + 1] = make_float4(__int_as_float(shader_id), radius, cosangle, invarea);
-			light_data[i*LIGHT_SIZE + 2] = make_float4(0.0f, 0.0f, 0.0f, 0.0f);
-			light_data[i*LIGHT_SIZE + 3] = make_float4(samples, 0.0f, 0.0f, 0.0f);
-			light_data[i*LIGHT_SIZE + 4] = make_float4(max_bounces, 0.0f, 0.0f, 0.0f);
+			light_data[pos*LIGHT_SIZE + 0] = make_float4(__int_as_float(light->type), dir.x, dir.y, dir.z);
+			light_data[pos*LIGHT_SIZE + 1] = make_float4(__int_as_float(shader_id), radius, cosangle, invarea);
+			light_data[pos*LIGHT_SIZE + 2] = make_float4(0.0f, 0.0f, 0.0f, 0.0f);
+			light_data[pos*LIGHT_SIZE + 3] = make_float4(samples, 0.0f, 0.0f, 0.0f);
+			light_data[pos*LIGHT_SIZE + 4] = make_float4(max_bounces, 0.0f, 0.0f, 0.0f);
 		}
 		else if(light->type == LIGHT_BACKGROUND) {
 			uint visibility = scene->background->visibility;
@@ -573,11 +610,11 @@ void LightManager::device_update_points(Device *device, DeviceScene *dscene, Sce
 				use_light_visibility = true;
 			}
 
-			light_data[i*LIGHT_SIZE + 0] = make_float4(__int_as_float(light->type), 0.0f, 0.0f, 0.0f);
-			light_data[i*LIGHT_SIZE + 1] = make_float4(__int_as_float(shader_id), 0.0f, 0.0f, 0.0f);
-			light_data[i*LIGHT_SIZE + 2] = make_float4(0.0f, 0.0f, 0.0f, 0.0f);
-			light_data[i*LIGHT_SIZE + 3] = make_float4(samples, 0.0f, 0.0f, 0.0f);
-			light_data[i*LIGHT_SIZE + 4] = make_float4(max_bounces, 0.0f, 0.0f, 0.0f);
+			light_data[pos*LIGHT_SIZE + 0] = make_float4(__int_as_float(light->type), 0.0f, 0.0f, 0.0f);
+			light_data[pos*LIGHT_SIZE + 1] = make_float4(__int_as_float(shader_id), 0.0f, 0.0f, 0.0f);
+			light_data[pos*LIGHT_SIZE + 2] = make_float4(0.0f, 0.0f, 0.0f, 0.0f);
+			light_data[pos*LIGHT_SIZE + 3] = make_float4(samples, 0.0f, 0.0f, 0.0f);
+			light_data[pos*LIGHT_SIZE + 4] = make_float4(max_bounces, 0.0f, 0.0f, 0.0f);
 		}
 		else if(light->type == LIGHT_AREA) {
 			float3 axisu = light->axisu*(light->sizeu*light->size);
@@ -591,11 +628,11 @@ void LightManager::device_update_points(Device *device, DeviceScene *dscene, Sce
 			if(light->use_mis && area > 0.0f)
 				shader_id |= SHADER_USE_MIS;
 
-			light_data[i*LIGHT_SIZE + 0] = make_float4(__int_as_float(light->type), co.x, co.y, co.z);
-			light_data[i*LIGHT_SIZE + 1] = make_float4(__int_as_float(shader_id), axisu.x, axisu.y, axisu.z);
-			light_data[i*LIGHT_SIZE + 2] = make_float4(invarea, axisv.x, axisv.y, axisv.z);
-			light_data[i*LIGHT_SIZE + 3] = make_float4(samples, dir.x, dir.y, dir.z);
-			light_data[i*LIGHT_SIZE + 4] = make_float4(max_bounces, 0.0f, 0.0f, 0.0f);
+			light_data[pos*LIGHT_SIZE + 0] = make_float4(__int_as_float(light->type), co.x, co.y, co.z);
+			light_data[pos*LIGHT_SIZE + 1] = make_float4(__int_as_float(shader_id), axisu.x, axisu.y, axisu.z);
+			light_data[pos*LIGHT_SIZE + 2] = make_float4(invarea, axisv.x, axisv.y, axisv.z);
+			light_data[pos*LIGHT_SIZE + 3] = make_float4(samples, dir.x, dir.y, dir.z);
+			light_data[pos*LIGHT_SIZE + 4] = make_float4(max_bounces, 0.0f, 0.0f, 0.0f);
 		}
 		else if(light->type == LIGHT_SPOT) {
 			shader_id &= ~SHADER_AREA_LIGHT;
@@ -611,13 +648,40 @@ void LightManager::device_update_points(Device *device, DeviceScene *dscene, Sce
 			if(light->use_mis && radius > 0.0f)
 				shader_id |= SHADER_USE_MIS;
 
-			light_data[i*LIGHT_SIZE + 0] = make_float4(__int_as_float(light->type), co.x, co.y, co.z);
-			light_data[i*LIGHT_SIZE + 1] = make_float4(__int_as_float(shader_id), radius, invarea, spot_angle);
-			light_data[i*LIGHT_SIZE + 2] = make_float4(spot_smooth, dir.x, dir.y, dir.z);
-			light_data[i*LIGHT_SIZE + 3] = make_float4(samples, 0.0f, 0.0f, 0.0f);
-			light_data[i*LIGHT_SIZE + 4] = make_float4(max_bounces, 0.0f, 0.0f, 0.0f);
+			light_data[pos*LIGHT_SIZE + 0] = make_float4(__int_as_float(light->type), co.x, co.y, co.z);
+			light_data[pos*LIGHT_SIZE + 1] = make_float4(__int_as_float(shader_id), radius, invarea, spot_angle);
+			light_data[pos*LIGHT_SIZE + 2] = make_float4(spot_smooth, dir.x, dir.y, dir.z);
+			light_data[pos*LIGHT_SIZE + 3] = make_float4(samples, 0.0f, 0.0f, 0.0f);
+			light_data[pos*LIGHT_SIZE + 4] = make_float4(max_bounces, 0.0f, 0.0f, 0.0f);
 		}
+
+		pos++;
 	}
+
+	foreach(Light *light, scene->lights) {
+		if (!light->portal) continue;
+		assert(light->type == LIGHT_AREA);
+
+
+		float3 co = light->co;
+		float3 axisu = light->axisu*(light->sizeu*light->size);
+		float3 axisv = light->axisv*(light->sizev*light->size);
+		float area = len(axisu)*len(axisv);
+		float invarea = (area > 0.0f) ? 1.0f / area : 1.0f;
+		float3 dir = light->dir;
+
+		dir = safe_normalize(dir);
+
+		light_data[pos*LIGHT_SIZE + 0] = make_float4(__int_as_float(light->type), co.x, co.y, co.z);
+		light_data[pos*LIGHT_SIZE + 1] = make_float4(area, axisu.x, axisu.y, axisu.z);
+		light_data[pos*LIGHT_SIZE + 2] = make_float4(invarea, axisv.x, axisv.y, axisv.z);
+		light_data[pos*LIGHT_SIZE + 3] = make_float4(-1, dir.x, dir.y, dir.z);
+		light_data[pos*LIGHT_SIZE + 4] = make_float4(-1, 0.0f, 0.0f, 0.0f);
+
+		pos++;
+	}
+
+	assert(pos == scene->lights.size());
 	
 	device->tex_alloc("__light_data", dscene->light_data);
 }
diff --git a/intern/cycles/render/light.h b/intern/cycles/render/light.h
index 1f8eac6..cbb4290 100644
--- a/intern/cycles/render/light.h
+++ b/intern/cycles/render/light.h
@@ -56,6 +56,8 @@ public:
 	bool use_transmission;
 	bool use_scatter;
 
+	bool portal;
+
 	int shader;
 	int samples;
 	int max_bounces;
diff --git a/intern/cycles/render/nodes.cpp b/intern/cycles/render/nodes.cpp
index 7a39811..9cf2da3 100644
--- a/intern/cycles/render/nodes.cpp
+++ b/intern/cycles/render/nodes.cpp
@@ -2003,6 +2003,29 @@ void HoldoutNode::compile(OSLCompiler& compiler)
 	compiler.add(this, "node_holdout");
 }
 
+/* Shadow Catcher Closure */
+
+ShadowCatcherNode::ShadowCatcherNode()
+: ShaderNode("shadow_catcher")
+{
+	add_input("SurfaceMixWeight", SHADER_SOCKET_FLOAT, 0.0f, ShaderInput::USE_SVM);
+	add_input("VolumeMixWeight", SHADER_SOCKET_FLOAT, 0.0f, ShaderInput::USE_SVM);
+	add_output("ShadowCatcher", SHADER_SOCKET_CLOSURE);
+}
+
+void ShadowCatcherNode::compile(SVMCompiler& compiler)
+{
+	float3 value = make_float3(1.0f, 1.0f, 1.0f);
+
+	compiler.add_node(NODE_CLOSURE_SET_WEIGHT, value);
+	compiler.add_node(NODE_CLOSURE_SHADOW_CATCHER, compiler.closure_mix_weight_offset());
+}
+
+void ShadowCatcherNode::compile(OSLCompiler& compiler)
+{
+	compiler.add(this, "node_shadow_catcher");
+}
+
 /* Ambient Occlusion */
 
 AmbientOcclusionNode::AmbientOcclusionNode()
diff --git a/intern/cycles/render/nodes.h b/intern/cycles/render/nodes.h
index 0ec0fce..e24a84e 100644
--- a/intern/cycles/render/nodes.h
+++ b/intern/cycles/render/nodes.h
@@ -310,6 +310,11 @@ public:
 	SHADER_NODE_CLASS(HoldoutNode)
 };
 
+class ShadowCatcherNode : public ShaderNode {
+public:
+	SHADER_NODE_CLASS(ShadowCatcherNode)
+};
+
 class AmbientOcclusionNode : public ShaderNode {
 public:
 	SHADER_NODE_CLASS(AmbientOcclusionNode)
diff --git a/intern/cycles/render/session.cpp b/intern/cycles/render/session.cpp
index 99826aa..1576b38 100644
--- a/intern/cycles/render/session.cpp
+++ b/intern/cycles/render/session.cpp
@@ -27,6 +27,7 @@
 
 #include "util_foreach.h"
 #include "util_function.h"
+#include "util_importance.h"
 #include "util_math.h"
 #include "util_opengl.h"
 #include "util_task.h"
@@ -42,7 +43,8 @@ Session::Session(const SessionParams& params_)
 : params(params_),
   tile_manager(params.progressive, params.samples, params.tile_size, params.start_resolution,
        params.background == false || params.progressive_refine, params.background, params.tile_order,
-       max(params.device.multi_devices.size(), 1)),
+       params.stopping_threshold, params.map_interval, max(params.device.multi_devices.size(), 1),
+       params.error_progressive),
   stats()
 {
 	device_use_gl = ((params.device.type != DEVICE_CPU) && !params.background);
@@ -223,7 +225,7 @@ void Session::run_gpu()
 				 */
 			}
 			else if(pause || no_tiles) {
-				update_status_time(pause, no_tiles);
+				update_status_time(false, pause, no_tiles);
 
 				while(1) {
 					double pause_start = time_dt();
@@ -234,7 +236,7 @@ void Session::run_gpu()
 						progress.set_start_time(start_time + paused_time);
 					progress.set_render_start_time(start_time + paused_time);
 
-					update_status_time(pause, no_tiles);
+					update_status_time(false, pause, no_tiles);
 					progress.set_update();
 
 					if(!pause)
@@ -264,7 +266,7 @@ void Session::run_gpu()
 			thread_scoped_lock buffers_lock(buffers_mutex);
 
 			/* update status and timing */
-			update_status_time();
+			update_status_time(false);
 
 			/* path trace */
 			path_trace();
@@ -275,7 +277,7 @@ void Session::run_gpu()
 				progress.set_cancel(device->error_message());
 
 			/* update status and timing */
-			update_status_time();
+			update_status_time(false);
 
 			gpu_need_tonemap = true;
 			gpu_draw_ready = true;
@@ -347,7 +349,7 @@ bool Session::draw_cpu(BufferParams& buffer_params, DeviceDrawParams& draw_param
 bool Session::acquire_tile(Device *tile_device, RenderTile& rtile)
 {
 	if(progress.get_cancel()) {
-		if(params.progressive_refine == false) {
+		if(params.progressive_refine == false || params.error_progressive) {
 			/* for progressive refine current sample should be finished for all tiles */
 			return false;
 		}
@@ -367,9 +369,14 @@ bool Session::acquire_tile(Device *tile_device, RenderTile& rtile)
 	rtile.y = tile_manager.state.buffer.full_y + tile.y;
 	rtile.w = tile.w;
 	rtile.h = tile.h;
-	rtile.start_sample = tile_manager.state.sample;
+	rtile.start_sample = params.error_progressive? tile.sample: tile_manager.state.sample;
+	rtile.sample = rtile.start_sample;
 	rtile.num_samples = tile_manager.state.num_samples;
 	rtile.resolution = tile_manager.state.resolution_divider;
+	rtile.t_x = tile.x;
+	rtile.t_y = tile.y;
+	rtile.t_device = tile.device;
+	rtile.t_index = tile.index;
 
 	tile_lock.unlock();
 
@@ -439,20 +446,30 @@ void Session::update_tile_sample(RenderTile& rtile)
 	thread_scoped_lock tile_lock(tile_mutex);
 
 	if(update_render_tile_cb) {
-		if(params.progressive_refine == false) {
+		if(params.progressive_refine == false || params.error_progressive) {
 			/* todo: optimize this by making it thread safe and removing lock */
 
 			update_render_tile_cb(rtile);
 		}
 	}
 
-	update_status_time();
+	update_status_time(true);
 }
 
 void Session::release_tile(RenderTile& rtile)
 {
 	thread_scoped_lock tile_lock(tile_mutex);
 
+	if(params.error_progressive) {
+		if(rtile.sample >= params.samples)
+			rtile.t_priority = 0.0f;
+		else
+			rtile.t_priority = tile_error(rtile);
+
+		if(update_render_tile_cb)
+			update_render_tile_cb(rtile);
+	}
+
 	if(write_render_tile_cb) {
 		if(params.progressive_refine == false) {
 			/* todo: optimize this by making it thread safe and removing lock */
@@ -462,7 +479,8 @@ void Session::release_tile(RenderTile& rtile)
 		}
 	}
 
-	update_status_time();
+	update_status_time(true);
+	tile_manager.finished_tile(Tile(rtile));
 }
 
 void Session::run_cpu()
@@ -508,7 +526,7 @@ void Session::run_cpu()
 				delayed_reset.do_reset = false;
 			}
 			else if(pause || no_tiles) {
-				update_status_time(pause, no_tiles);
+				update_status_time(false, pause, no_tiles);
 
 				while(1) {
 					double pause_start = time_dt();
@@ -519,7 +537,7 @@ void Session::run_cpu()
 						progress.set_start_time(start_time + paused_time);
 					progress.set_render_start_time(start_time + paused_time);
 
-					update_status_time(pause, no_tiles);
+					update_status_time(false, pause, no_tiles);
 					progress.set_update();
 
 					if(!pause)
@@ -547,13 +565,13 @@ void Session::run_cpu()
 				break;
 
 			/* update status and timing */
-			update_status_time();
+			update_status_time(false);
 
 			/* path trace */
 			path_trace();
 
 			/* update status and timing */
-			update_status_time();
+			update_status_time(false);
 
 			if(!params.background)
 				need_tonemap = true;
@@ -651,6 +669,8 @@ bool Session::draw(BufferParams& buffer_params, DeviceDrawParams &draw_params)
 
 void Session::reset_(BufferParams& buffer_params, int samples)
 {
+	buffer_params.use_importance = params.adaptive_distribution;
+
 	if(buffers) {
 		if(buffer_params.modified(buffers->params)) {
 			gpu_draw_ready = false;
@@ -767,7 +787,7 @@ void Session::update_scene()
 	}
 }
 
-void Session::update_status_time(bool show_pause, bool show_done)
+void Session::update_status_time(bool tile_locked, bool show_pause, bool show_done)
 {
 	int sample = tile_manager.state.sample;
 	int resolution = tile_manager.state.resolution_divider;
@@ -784,7 +804,7 @@ void Session::update_status_time(bool show_pause, bool show_done)
 
 		substatus = string_printf("Path Tracing Tile %d/%d", tile, num_tiles);
 
-		if((is_gpu && !is_multidevice) || (is_cpu && num_tiles == 1)) {
+		if(((is_gpu && !is_multidevice) || (is_cpu && num_tiles == 1)) && params.stopping_threshold == 0.0f) {
 			/* when rendering on GPU multithreading happens within single tile, as in
 			 * tiles are handling sequentially and in this case we could display
 			 * currently rendering sample number
@@ -805,6 +825,21 @@ void Session::update_status_time(bool show_pause, bool show_done)
 			substatus += string_printf(", Sample %d/%d", sample, num_samples);
 		}
 	}
+	else if(params.error_progressive) {
+		float worst_error;
+		if(tile_locked)
+			worst_error = tile_manager.state.tiles.top().priority;
+		else {
+			thread_scoped_lock tile_lock(tile_mutex);
+			worst_error = tile_manager.state.tiles.top().priority;
+		}
+		if(worst_error >= 1e5f)
+			substatus = string_printf("Path Tracing, First Pass");
+		else {
+			float confidence = 100.0f * fast_erff(1.0f / (M_SQRT2_F*worst_error));
+			substatus = string_printf("Path Tracing, Confidence %f", (double) confidence);
+		}
+	}
 	else if(tile_manager.num_samples == USHRT_MAX)
 		substatus = string_printf("Path Tracing Sample %d", sample+1);
 	else
@@ -850,8 +885,13 @@ void Session::path_trace()
 	task.get_cancel = function_bind(&Progress::get_cancel, &this->progress);
 	task.update_tile_sample = function_bind(&Session::update_tile_sample, this, _1);
 	task.update_progress_sample = function_bind(&Session::update_progress_sample, this);
-	task.need_finish_queue = params.progressive_refine;
+	task.need_finish_queue = params.progressive_refine && !params.error_progressive;
 	task.integrator_branched = scene->integrator->method == Integrator::BRANCHED_PATH;
+	task.adaptive_stopping = params.adaptive_stopping;
+	task.adaptive_distribution = params.adaptive_distribution;
+	task.stopping_threshold = params.stopping_threshold;
+	task.map_interval = params.map_interval;
+	task.error_progressive = params.error_progressive;
 
 	device->task_add(task);
 }
@@ -895,7 +935,7 @@ bool Session::update_progressive_refine(bool cancel)
 			return false;
 	}
 
-	if(params.progressive_refine) {
+	if(params.progressive_refine && !params.error_progressive) {
 		foreach(RenderBuffers *buffers, tile_buffers) {
 			RenderTile rtile;
 			rtile.buffers = buffers;
diff --git a/intern/cycles/render/session.h b/intern/cycles/render/session.h
index c77652d..73733e5 100644
--- a/intern/cycles/render/session.h
+++ b/intern/cycles/render/session.h
@@ -46,6 +46,12 @@ public:
 	bool progressive_refine;
 	string output_path;
 
+	bool adaptive_distribution;
+	bool adaptive_stopping;
+	float stopping_threshold;
+	int map_interval;
+	bool error_progressive;
+
 	bool progressive;
 	bool experimental;
 	int samples;
@@ -94,6 +100,11 @@ public:
 		&& progressive_refine == params.progressive_refine
 		&& output_path == params.output_path
 		/* && samples == params.samples */
+		&& adaptive_stopping == params.adaptive_stopping
+		&& adaptive_distribution == params.adaptive_distribution
+		&& stopping_threshold == params.stopping_threshold
+		&& map_interval == params.map_interval
+		&& error_progressive == params.error_progressive
 		&& progressive == params.progressive
 		&& experimental == params.experimental
 		&& tile_size == params.tile_size
@@ -155,7 +166,7 @@ protected:
 
 	void run();
 
-	void update_status_time(bool show_pause = false, bool show_done = false);
+	void update_status_time(bool tile_locked, bool show_pause = false, bool show_done = false);
 
 	void tonemap(int sample);
 	void path_trace();
diff --git a/intern/cycles/render/tile.cpp b/intern/cycles/render/tile.cpp
index 675f49e..46bc5cc 100644
--- a/intern/cycles/render/tile.cpp
+++ b/intern/cycles/render/tile.cpp
@@ -17,20 +17,26 @@
 #include "tile.h"
 
 #include "util_algorithm.h"
+#include "util_hilbert.h"
 #include "util_types.h"
 
 CCL_NAMESPACE_BEGIN
 
 TileManager::TileManager(bool progressive_, int num_samples_, int2 tile_size_, int start_resolution_,
-                         bool preserve_tile_device_, bool background_, TileOrder tile_order_, int num_devices_)
+                         bool preserve_tile_device_, bool background_, TileOrder tile_order_,
+                         float stopping_threshold_, int map_interval_, int num_devices_,
+                         bool error_progressive_)
 {
 	progressive = progressive_;
+	error_progressive = error_progressive_;
 	tile_size = tile_size_;
 	tile_order = tile_order_;
 	start_resolution = start_resolution_;
 	num_devices = num_devices_;
 	preserve_tile_device = preserve_tile_device_;
 	background = background_;
+	stopping_threshold = stopping_threshold_;
+	map_interval = map_interval_;
 
 	BufferParams buffer_params;
 	reset(buffer_params, 0);
@@ -78,6 +84,7 @@ void TileManager::gen_tiles_global()
 	int resolution = state.resolution_divider;
 	int image_w = max(1, params.width/resolution);
 	int image_h = max(1, params.height/resolution);
+	int centx = image_w / 2, centy = image_h / 2;
 
 	state.tiles.clear();
 
@@ -97,8 +104,32 @@ void TileManager::gen_tiles_global()
 			int y = tile_y * tile_size.y;
 			int w = (tile_x == tile_w-1)? image_w - x: tile_size.x;
 			int h = (tile_y == tile_h-1)? image_h - y: tile_size.y;
+			
+			float priority = 1e5f + (image_w * image_h);
+			int distx, disty;
+			switch (tile_order) {
+				case TILE_CENTER:
+					distx = centx - (x + w);
+					disty = centy - (y + h);
+					priority -= sqrtf((float)(distx * distx + disty * disty));
+					break;
+				case TILE_RIGHT_TO_LEFT:
+					priority -= (image_w - x - 1) * image_h + y;
+					break;
+				case TILE_LEFT_TO_RIGHT:
+					priority -= x * image_h + y;
+					break;
+				case TILE_TOP_TO_BOTTOM:
+					priority -= (image_h - y - 1) * image_w + x;
+					break;
+				case TILE_BOTTOM_TO_TOP:
+					priority -= y * image_w + x;
+					break;
+				default:
+					break;
+			}
 
-			state.tiles.push_back(Tile(tile_index, x, y, w, h, cur_device));
+			state.tiles.push_back(Tile(tile_index, x, y, w, h, cur_device, priority));
 			cur_tiles++;
 
 			if(cur_tiles == tiles_per_device) {
@@ -115,6 +146,7 @@ void TileManager::gen_tiles_sliced()
 	int resolution = state.resolution_divider;
 	int image_w = max(1, params.width/resolution);
 	int image_h = max(1, params.height/resolution);
+	int centx = image_w / 2, centy = image_h / 2;
 
 	state.tiles.clear();
 
@@ -136,7 +168,7 @@ void TileManager::gen_tiles_sliced()
 				int w = (tile_x == tile_w-1)? image_w - x: tile_size.x;
 				int h = (tile_y == tile_h-1)? device_h - y: tile_size.y;
 
-				state.tiles.push_back(Tile(tile_index, x, y + device_y, w, h, device));
+				state.tiles.push_back(Tile(tile_index, x, y + device_y, w, h, device, 1e5f));
 			}
 		}
 	}
@@ -164,9 +196,9 @@ void TileManager::set_tiles()
 	state.buffer.full_height = max(1, params.full_height/resolution);
 }
 
-list<Tile>::iterator TileManager::next_viewport_tile(int device)
+PriorityQueue<Tile>::iterator TileManager::next_viewport_tile(int device)
 {
-	list<Tile>::iterator iter;
+	PriorityQueue<Tile>::iterator iter;
 
 	int logical_device = preserve_tile_device? device: 0;
 
@@ -178,9 +210,9 @@ list<Tile>::iterator TileManager::next_viewport_tile(int device)
 	return state.tiles.end();
 }
 
-list<Tile>::iterator TileManager::next_background_tile(int device, TileOrder tile_order)
+PriorityQueue<Tile>::iterator TileManager::next_background_tile(int device, TileOrder tile_order)
 {
-	list<Tile>::iterator iter, best = state.tiles.end();
+	PriorityQueue<Tile>::iterator iter, best = state.tiles.end();
 
 	int resolution = state.resolution_divider;
 	int logical_device = preserve_tile_device? device: 0;
@@ -191,6 +223,8 @@ list<Tile>::iterator TileManager::next_background_tile(int device, TileOrder til
 	
 	int64_t centx = cordx / 2, centy = cordy / 2;
 
+	int64_t hilbert_n = hilbert_roundpow2(max((params.width + tile_size.x - 1) / tile_size.x, (params.height + tile_size.y - 1) / tile_size.y));
+
 	for(iter = state.tiles.begin(); iter != state.tiles.end(); iter++) {
 		if(iter->device == logical_device && iter->rendering == false) {
 			Tile &cur_tile = *iter;
@@ -216,6 +250,9 @@ list<Tile>::iterator TileManager::next_background_tile(int device, TileOrder til
 				case TILE_BOTTOM_TO_TOP:
 					distx = cordx + cur_tile.y;
 					break; 
+				case TILE_HILBERT:
+					distx = hilbert_xy2d(hilbert_n, cur_tile.x / tile_size.x, cur_tile.y / tile_size.y);
+					break;
 				default:
 					break;
 			}
@@ -232,7 +269,30 @@ list<Tile>::iterator TileManager::next_background_tile(int device, TileOrder til
 
 bool TileManager::next_tile(Tile& tile, int device)
 {
-	list<Tile>::iterator tile_it;
+	int logical_device = preserve_tile_device? device: 0;
+	if(error_progressive) {
+		list<Tile> wrong_device; /* Tiles that had worse error but are on the wrong device */
+		while(!state.tiles.empty()) {
+			Tile t = state.tiles.top();
+			state.tiles.pop();
+			if(t.device != logical_device)
+				wrong_device.push_back(t);
+			else {
+				for(list<Tile>::iterator iter = wrong_device.begin(); iter != wrong_device.end(); iter++)
+					state.tiles.push(*iter);
+				if(t.priority <= stopping_threshold) /* Done (for this device) since the worst error is below threshold */
+					return false;
+				tile = t;
+				state.num_rendered_tiles++;
+				return true;
+			}
+		}
+		for(list<Tile>::iterator iter = wrong_device.begin(); iter != wrong_device.end(); iter++) /* No tile (for this device) left */
+			state.tiles.push(*iter);
+		return false;
+	}
+
+	PriorityQueue<Tile>::iterator tile_it;
 	
 	if (background)
 		tile_it = next_background_tile(device, tile_order);
@@ -250,9 +310,23 @@ bool TileManager::next_tile(Tile& tile, int device)
 	return false;
 }
 
+void TileManager::finished_tile(Tile tile)
+{
+	if(error_progressive) {
+		state.tiles.push_back(tile);
+		/* Finished warmup? */
+		if(state.num_samples != 3*map_interval && state.tiles.top().priority < 1e5f)
+			state.num_samples = map_interval;
+	}
+}
+
 bool TileManager::done()
 {
-	return (state.sample+state.num_samples >= num_samples && state.resolution_divider == 1);
+	if(error_progressive)
+		/* If the queue is empty, no tiles have yet been generated */
+		return state.tiles.empty()? false: state.tiles.top().priority <= stopping_threshold;
+	else
+		return (state.sample+state.num_samples >= num_samples && state.resolution_divider == 1);
 }
 
 bool TileManager::next()
@@ -260,7 +334,13 @@ bool TileManager::next()
 	if(done())
 		return false;
 
-	if(progressive && state.resolution_divider > 1) {
+	if(error_progressive) {
+		state.sample = 0;
+		state.num_samples = 3*map_interval;
+		state.resolution_divider = 1;
+		set_tiles();
+	}
+	else if(progressive && state.resolution_divider > 1) {
 		state.sample = 0;
 		state.resolution_divider /= 2;
 		state.num_samples = 1;
diff --git a/intern/cycles/render/tile.h b/intern/cycles/render/tile.h
index c9bdc86..22a5af6 100644
--- a/intern/cycles/render/tile.h
+++ b/intern/cycles/render/tile.h
@@ -31,13 +31,25 @@ public:
 	int index;
 	int x, y, w, h;
 	int device;
+	int sample;
+	float priority;
 	bool rendering;
 
 	Tile()
 	{}
 
-	Tile(int index_, int x_, int y_, int w_, int h_, int device_)
-	: index(index_), x(x_), y(y_), w(w_), h(h_), device(device_), rendering(false) {}
+	Tile(int index_, int x_, int y_, int w_, int h_, int device_, float priority_)
+	: index(index_), x(x_), y(y_), w(w_), h(h_), device(device_), sample(0), priority(priority_), rendering(false) {}
+	Tile(const RenderTile &rtile)
+	: index(rtile.t_index), x(rtile.t_x), y(rtile.t_y), w(rtile.w), h(rtile.h), device(rtile.t_device), sample(rtile.start_sample + rtile.num_samples), priority(rtile.t_priority), rendering(false) {}
+
+	bool operator<(const Tile &b) const {
+		if(priority < b.priority)
+			return true;
+		if(priority == b.priority)
+			return index > b.index;
+		return false;
+	}
 };
 
 /* Tile order */
@@ -48,7 +60,8 @@ enum TileOrder {
 	TILE_RIGHT_TO_LEFT = 1,
 	TILE_LEFT_TO_RIGHT = 2,
 	TILE_TOP_TO_BOTTOM = 3,
-	TILE_BOTTOM_TO_TOP = 4
+	TILE_BOTTOM_TO_TOP = 4,
+	TILE_HILBERT = 5
 };
 
 /* Tile Manager */
@@ -64,19 +77,22 @@ public:
 		int resolution_divider;
 		int num_tiles;
 		int num_rendered_tiles;
-		list<Tile> tiles;
+		PriorityQueue<Tile> tiles;
 	} state;
 
 	int num_samples;
 
 	TileManager(bool progressive, int num_samples, int2 tile_size, int start_resolution,
-	            bool preserve_tile_device, bool background, TileOrder tile_order, int num_devices = 1);
+	            bool preserve_tile_device, bool background, TileOrder tile_order,
+				float stopping_threshold, int map_interval, int num_devices,
+				bool error_progressive);
 	~TileManager();
 
 	void reset(BufferParams& params, int num_samples);
 	void set_samples(int num_samples);
 	bool next();
 	bool next_tile(Tile& tile, int device = 0);
+	void finished_tile(Tile tile);
 	bool done();
 	
 	void set_tile_order(TileOrder tile_order_) { tile_order = tile_order_; }
@@ -85,10 +101,13 @@ protected:
 	void set_tiles();
 
 	bool progressive;
+	bool error_progressive;
 	int2 tile_size;
 	TileOrder tile_order;
 	int start_resolution;
 	int num_devices;
+	float stopping_threshold;
+	int map_interval;
 
 	/* in some cases it is important that the same tile will be returned for the same
 	 * device it was originally generated for (i.e. viewport rendering when buffer is
@@ -116,10 +135,10 @@ protected:
 	void gen_tiles_sliced();
 
 	/* returns tiles for background render */
-	list<Tile>::iterator next_background_tile(int device, TileOrder tile_order);
+	PriorityQueue<Tile>::iterator next_background_tile(int device, TileOrder tile_order);
 
 	/* returns first unhandled tile for viewport render */
-	list<Tile>::iterator next_viewport_tile(int device);
+	PriorityQueue<Tile>::iterator next_viewport_tile(int device);
 };
 
 CCL_NAMESPACE_END
diff --git a/intern/cycles/util/CMakeLists.txt b/intern/cycles/util/CMakeLists.txt
index 0acb9e9..328d73f 100644
--- a/intern/cycles/util/CMakeLists.txt
+++ b/intern/cycles/util/CMakeLists.txt
@@ -2,6 +2,9 @@
 set(INC
 	.
 	../../glew-mx
+	../device
+	../kernel
+	../render
 )
 
 set(INC_SYS
@@ -12,6 +15,7 @@ set(SRC
 	util_aligned_malloc.cpp
 	util_cache.cpp
 	util_logging.cpp
+	util_importance.cpp
 	util_md5.cpp
 	util_path.cpp
 	util_string.cpp
@@ -44,7 +48,9 @@ set(SRC_HEADERS
 	util_function.h
 	util_half.h
 	util_hash.h
+	util_hilbert.h
 	util_image.h
+	util_importance.h
 	util_list.h
 	util_logging.h
 	util_map.h
diff --git a/intern/cycles/util/util_color.h b/intern/cycles/util/util_color.h
index d3598f8..cf1471c 100644
--- a/intern/cycles/util/util_color.h
+++ b/intern/cycles/util/util_color.h
@@ -239,6 +239,28 @@ ccl_device float linear_rgb_to_gray(float3 c)
 	return c.x*0.2126f + c.y*0.7152f + c.z*0.0722f;
 }
 
+ccl_device float linear_rgba_to_gray(float4 c)
+{
+	return c.x*0.2126f + c.y*0.7152f + c.z*0.0722f;
+}
+
+ccl_device float linear_gray_to_inv_tvi(float v) {
+	//Based on eq. 4 from "A Model of Visual Adaptation for Realistic Image Synthesis", with a display luminance of 200 cd/m^2
+	v *= 200.f;
+	if(v < 1e-6f)
+		return expf(0.72f * logf(10.0f));
+
+	float log_v = log10f(v);
+	float log_i;
+	if(log_v < -2.6f)
+		log_i = -0.72f;
+	else if(log_v < 1.9f)
+		log_i = powf(0.249f*log_v + 0.65f, 2.7f) - 0.72f;
+	else
+        log_i = log_v - 1.255f;
+	return expf(-log_i * logf(10.0f)) * 200.f;
+}
+
 CCL_NAMESPACE_END
 
 #endif /* __UTIL_COLOR_H__ */
diff --git a/intern/cycles/util/util_hilbert.h b/intern/cycles/util/util_hilbert.h
new file mode 100644
index 0000000..8ff5418
--- /dev/null
+++ b/intern/cycles/util/util_hilbert.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2011-2015 Blender Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef __UTIL_HILBERT_H__
+#define __UTIL_HILBERT_H__
+
+CCL_NAMESPACE_BEGIN
+
+inline int hilbert_roundpow2(int v) {
+	v--;
+	v |= v >> 1;
+	v |= v >> 2;
+	v |= v >> 4;
+	v |= v >> 8;
+	v |= v >> 16;
+	v++;
+	return v;
+}
+
+//Source: http://en.wikipedia.org/wiki/Hilbert_curve
+inline void hilbert_rot(int n, int *x, int *y, int rx, int ry) {
+	if (ry == 0) {
+		if (rx == 1) {
+			*x = n-1 - *x;
+			*y = n-1 - *y;
+		}
+
+		//Swap x and y
+		int t  = *x;
+		*x = *y;
+		*y = t;
+	}
+}
+
+inline int hilbert_xy2d (int n, int x, int y) {
+	int rx, ry, s, d=0;
+	for (s=n/2; s>0; s/=2) {
+		rx = (x & s) > 0;
+		ry = (y & s) > 0;
+		d += s * s * ((3 * rx) ^ ry);
+		hilbert_rot(s, &x, &y, rx, ry);
+	}
+	return d;
+}
+
+inline void hilbert_d2xy(int n, int d, int *x, int *y) {
+	int rx, ry, s, t=d;
+	*x = *y = 0;
+	for (s=1; s<n; s*=2) {
+		rx = 1 & (t/2);
+		ry = 1 & (t ^ rx);
+		hilbert_rot(s, x, y, rx, ry);
+		*x += s * rx;
+		*y += s * ry;
+		t /= 4;
+	}
+}
+
+CCL_NAMESPACE_END
+
+#endif // __UTIL_HILBERT_H__
+
diff --git a/intern/cycles/util/util_importance.cpp b/intern/cycles/util/util_importance.cpp
new file mode 100644
index 0000000..2ed00d0
--- /dev/null
+++ b/intern/cycles/util/util_importance.cpp
@@ -0,0 +1,268 @@
+/*
+ * Copyright 2011-2014 Blender Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+
+#include <algorithm>
+#include <cmath>
+
+#include "util_color.h"
+#include "util_foreach.h"
+#include "util_hash.h"
+#include "util_importance.h"
+
+#include "buffers.h"
+#include "tile.h"
+
+CCL_NAMESPACE_BEGIN
+
+//Gaussian blur kernel (size 4)
+static const float gaussian_4[] = {0.30406f, 0.22855f, 0.09681f, 0.02262f};
+
+bool find_passes(RenderTile &rtile, int &samples_pass_o, int &variance_pass_o) {
+	samples_pass_o = 0;
+	variance_pass_o = 0;
+	bool found_samples_pass = false, found_variance_pass = false;
+	foreach(Pass& pass, rtile.buffers->params.passes) {
+		if(pass.type == PASS_SAMPLES) {
+			found_samples_pass = true;
+			break;
+		}
+		samples_pass_o += pass.components;
+	}
+	foreach(Pass& pass, rtile.buffers->params.passes) {
+		if(pass.type == PASS_VARIANCE) {
+			found_variance_pass = true;
+			break;
+		}
+		variance_pass_o += pass.components;
+	}
+	return found_samples_pass && found_variance_pass;
+}
+
+ImportanceMap::ImportanceMap(RenderTile &rtile)
+{
+	width = rtile.w;
+	height = rtile.h;
+	data = new float[width*height];
+	marginal = new float[height];
+
+	rtile.buffers->copy_from_device();
+
+	int pass_stride = rtile.buffers->params.get_passes_size();
+	float *passes = (float*)rtile.buffers->buffer.data_pointer + (rtile.offset + rtile.x + rtile.y*rtile.stride)*pass_stride;
+	float *importance = &rtile.buffers->importance_map[rtile.offset + rtile.x + rtile.y*rtile.stride];
+
+	int samples_pass_o = 0, variance_pass_o = 0;
+	if(!find_passes(rtile, samples_pass_o, variance_pass_o))
+		return;
+
+	for(int y = 0; y < height; y++) {
+		for(int x = 0; x < width; x++, passes += pass_stride, importance++) {
+			float4 *combined_pass, *variance_pass;
+			float *samples_pass;
+			combined_pass = (float4*) passes;
+			variance_pass = (float4*) (passes + variance_pass_o);
+			samples_pass = passes + samples_pass_o;
+
+			if(*samples_pass < 2)
+				*importance = 10;
+			else {
+				float samples_factor = 1.f / *samples_pass;
+				float intensity_factor = linear_gray_to_inv_tvi(linear_rgba_to_gray(*combined_pass * samples_factor));
+
+				float4 variance = (*variance_pass) / (*samples_pass - 1);
+				*importance = sqrtf(max(linear_rgba_to_gray(variance), 0.0f) * samples_factor) * intensity_factor;
+			}
+		}
+		importance += rtile.stride - width;
+		passes += (rtile.stride - width) * pass_stride;
+	}
+	importance = &rtile.buffers->importance_map[0];
+
+	/* Gaussian blur */
+	for(int y = 0; y < height; y++) {
+		for(int x = 0; x < width; x++) {
+			data[y*width + x] = 0;
+			for(int d = -3; d < 4; d++)
+				data[y*width + x] += gaussian_4[std::abs(d)] * importance[rtile.offset + rtile.x + (y+rtile.y)*rtile.stride + max(min(x + d, width-1), 0)];
+		}
+	}
+	for(int y = 0; y < height; y++) {
+		for(int x = 0; x < width; x++) {
+			importance[rtile.offset + rtile.x + (y+rtile.y)*rtile.stride + x] = 0;
+			for(int d = -3; d < 4; d++)
+				importance[rtile.offset + rtile.x + (y+rtile.y)*rtile.stride + x] += gaussian_4[std::abs(d)] * data[max(min(y + d, height-1), 0)*width + x];
+		}
+	}
+
+	/* Bilateral blur (gamma_space=6, gamma_color=0.5) */
+	for(int y = 0; y < height; y++) {
+		for(int x = 0; x < width; x++) {
+			float pixel_value = importance[rtile.offset + (y + rtile.y)*rtile.stride + rtile.x + x];
+			float weight = 0;
+			data[y * width + x] = 0;
+			for(int my = max(0, y - 6); my < min(height, y + 6); my++) {
+				for(int mx = max(0, x - 6); mx < min(width, x + 6); mx++) {
+					float value = importance[rtile.offset + (my + rtile.y)*rtile.stride + rtile.x + mx];
+					if(fabsf(value - pixel_value) < 0.5f) {
+						data[y * width + x] += value;
+						weight += 1.0f;
+					}
+				}
+			}
+			data[y * width + x] /= weight;
+		}
+	}
+
+	for(int y = 0; y < height; y++)
+		for(int x = 0; x < width; x++) {
+			data[y * width + x] *= data[y * width + x];
+			importance[rtile.offset + (y + rtile.y)*rtile.stride + rtile.x + x] = data[y * width + x];
+		}
+
+	/* Convert in-place to 2D CDF distribution */
+	for(int y = 0; y < height; y++) {
+		float *row = data + y*width;
+
+		for(int x = 1; x < width; x++)
+			row[x] += row[x-1];
+
+		marginal[y] = row[width-1];
+		if(y > 0)
+			marginal[y] += marginal[y-1];
+
+		float scale = 1.0f / row[width-1];
+		for(int x = 0; x < width; x++)
+			row[x] *= scale;
+	}
+
+	float scale = 1.0f / marginal[height-1];
+	for(int y = 0; y < height; y++)
+		marginal[y] *= scale;
+}
+
+ImportanceMap::~ImportanceMap()
+{
+	delete[] data;
+	delete[] marginal;
+}
+
+void ImportanceMap::sample(int sample, int &x, int &y)
+{
+	float u, v;
+	/* Sample 02-Sequence for pixel jittering (1D Sobol for v, Van-der-Corput for u) */
+	uint r = 0, i = sample;
+	for(uint va = 1U << 31; i; i >>= 1, va ^= va >> 1)
+		if(i & 1)
+			r ^= va;
+
+	uint rotation = hash_int_2d(x, y);
+	v = (float)r * (1.0f/(float)0xFFFFFFFF) + (rotation & 0xFFFF) * (1.0f/(float)0xFFFF);
+	v -= floorf(v);
+
+	i = (sample << 16) | (sample >> 16);
+	i = ((i & 0x00ff00ff) << 8) | ((i & 0xff00ff00) >> 8);
+	i = ((i & 0x0f0f0f0f) << 4) | ((i & 0xf0f0f0f0) >> 4);
+	i = ((i & 0x33333333) << 2) | ((i & 0xcccccccc) >> 2);
+	i = ((i & 0x55555555) << 1) | ((i & 0xaaaaaaaa) >> 1);
+	u = (float)i * (1.0f/(float)0xFFFFFFFF) + (rotation >> 16) * (1.0f/(float)0xFFFF);
+	u -= floorf(u);
+
+	/* Sample 2D CDF */
+	u = (x + u)/width;
+	v = (y + v)/height;
+	y = min(std::upper_bound(marginal, marginal + height, v) - marginal, height-1);
+	x = min(std::upper_bound(data + y*width, data + (y+1)*width, u) - (data + y*width), width-1);
+}
+
+float tile_error(RenderTile &rtile)
+{
+	rtile.buffers->copy_from_device();
+
+	int pass_stride = rtile.buffers->params.get_passes_size();
+	float *passes = (float*)rtile.buffers->buffer.data_pointer + (rtile.offset + rtile.x + rtile.y*rtile.stride)*pass_stride;
+	float *importance = &rtile.buffers->importance_map[rtile.offset + rtile.x + rtile.y*rtile.stride];
+
+	int samples_pass_o = 0, variance_pass_o = 0;
+	if(!find_passes(rtile, samples_pass_o, variance_pass_o))
+		return -1;
+
+	float *smooth_tvi = new float[rtile.w*rtile.h];
+	float *temp_gaussian = new float[rtile.w*rtile.h];
+	for(int y = 0; y < rtile.h; y++) {
+		for(int x = 0; x < rtile.w; x++) {
+			int index = (rtile.offset + (rtile.y + y)*rtile.stride + rtile.x + x)*pass_stride;
+			smooth_tvi[y*rtile.w + x] = linear_rgba_to_gray(*((float4*) (passes + index)) / passes[index + samples_pass_o]);
+		}
+	}
+	for(int y = 0; y < rtile.h; y++) {
+		for(int x = 0; x < rtile.w; x++) {
+			temp_gaussian[y*rtile.w + x] = 0;
+			for(int d = -3; d < 4; d++)
+				temp_gaussian[y*rtile.w + x] += gaussian_4[std::abs(d)] * smooth_tvi[y*rtile.w + max(min(x + d, rtile.w-1), 0)];
+		}
+	}
+	for(int y = 0; y < rtile.h; y++) {
+		for(int x = 0; x < rtile.w; x++) {
+			smooth_tvi[y*rtile.w + x] = 0;
+			for(int d = -3; d < 4; d++)
+				smooth_tvi[y*rtile.w + x] += gaussian_4[std::abs(d)] * temp_gaussian[max(min(y + d, rtile.h-1), 0)*rtile.w + x];
+			smooth_tvi[y*rtile.w + x] = linear_gray_to_inv_tvi(smooth_tvi[y*rtile.w + x]);
+		}
+	}
+	delete[] temp_gaussian;
+
+	double error = 0.0;
+	for(int y = 0; y < rtile.h; y++) {
+		for(int x = 0; x < rtile.w; x++, passes += pass_stride, importance++) {
+			float4 pixel_variance = *((float4*) (passes + variance_pass_o));
+			float pixel_samples = passes[samples_pass_o];
+
+			if(pixel_samples < 2)
+				return 1e5f;
+
+			float4 variance = pixel_variance / (pixel_samples - 1.0f);
+			float svariance = sqrtf(max(linear_rgba_to_gray(variance), 0.0f) / pixel_samples) * smooth_tvi[y*rtile.w + x];
+
+			error += pow((double) svariance, 5.0);
+		}
+		importance += rtile.stride - rtile.w;
+		passes += (rtile.stride - rtile.w) * pass_stride;
+	}
+
+	delete[] smooth_tvi;
+
+	error /= rtile.w * rtile.h;
+	return (float) pow(error, 0.2);
+}
+
+bool tile_converged(RenderTile &rtile, DeviceTask *task, int *next_check)
+{
+	if(task->error_progressive) {
+		*next_check += task->map_interval;
+		return false;
+	}
+	if(!task->adaptive_stopping)
+		return false;
+
+	float error = tile_error(rtile);
+	if(error < 0)
+		return false;
+	int converged_at = (int) (error*error * rtile.sample / (task->stopping_threshold*task->stopping_threshold));
+	*next_check = rtile.sample + max((converged_at - rtile.sample)/2, task->map_interval);
+	return (error <= task->stopping_threshold);
+}
+
+CCL_NAMESPACE_END
diff --git a/intern/cycles/util/util_importance.h b/intern/cycles/util/util_importance.h
new file mode 100644
index 0000000..63ba680
--- /dev/null
+++ b/intern/cycles/util/util_importance.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2011-2013 Blender Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+
+#ifndef __UTIL_IMPORTANCE_H__
+#define __UTIL_IMPORTANCE_H__
+
+#include <algorithm>
+#include "util_color.h"
+#include "buffers.h"
+#include "device_task.h"
+
+CCL_NAMESPACE_BEGIN
+
+float tile_error(RenderTile &rtile);
+bool tile_converged(RenderTile &rtile, DeviceTask *task, int *next_check);
+
+class ImportanceMap {
+public:
+	ImportanceMap(RenderTile &tile);
+	~ImportanceMap();
+
+	void sample(int sample, int &x, int &y);
+private:
+	float *data, *marginal;
+	int width, height;
+};
+
+CCL_NAMESPACE_END
+
+#endif /* __UTIL_IMPORTANCE_H__ */
diff --git a/intern/cycles/util/util_list.h b/intern/cycles/util/util_list.h
index 6cb27e6..ecff4b7 100644
--- a/intern/cycles/util/util_list.h
+++ b/intern/cycles/util/util_list.h
@@ -18,11 +18,23 @@
 #define __UTIL_LIST_H__
 
 #include <list>
+#include <queue>
 
 CCL_NAMESPACE_BEGIN
 
 using std::list;
 
+template<typename T, typename compare = std::less<T> >
+class PriorityQueue : public std::priority_queue<T, std::vector<T>, compare>
+{
+public:
+	typedef typename std::vector<T>::iterator iterator;
+	void clear() { this->c.clear(); }
+	iterator begin() { return this->c.begin(); }
+	iterator end() { return this->c.end(); }
+	void push_back(const T &v) { this->push(v); }
+};
+
 CCL_NAMESPACE_END
 
 #endif /* __UTIL_LIST_H__ */
diff --git a/intern/opencolorio/fallback_impl.cc b/intern/opencolorio/fallback_impl.cc
index d1493cb..a805e71 100644
--- a/intern/opencolorio/fallback_impl.cc
+++ b/intern/opencolorio/fallback_impl.cc
@@ -420,7 +420,8 @@ bool FallbackImpl::supportGLSLDraw(void)
 
 bool FallbackImpl::setupGLSLDraw(struct OCIO_GLSLDrawState ** /*state_r*/, OCIO_ConstProcessorRcPtr * /*processor*/,
                                  OCIO_CurveMappingSettings * /*curve_mapping_settings*/,
-                                 float /*dither*/,  bool /*predivide*/)
+                                 float /*dither*/, float /*white_value*/,
+                                 float /*exposure*/, bool /*predivide*/)
 {
 	return false;
 }
diff --git a/intern/opencolorio/gpu_shader_display_transform.glsl b/intern/opencolorio/gpu_shader_display_transform.glsl
index 5921d6d..3ba2713 100644
--- a/intern/opencolorio/gpu_shader_display_transform.glsl
+++ b/intern/opencolorio/gpu_shader_display_transform.glsl
@@ -14,7 +14,7 @@ uniform float image_texture_height;
 /* Curve mapping parameters
  *
  * See documentation for OCIO_CurveMappingSettings to get fields descriptions.
- * (this ones pretyt much copies stuff from C structure.)
+ * (this ones pretty much copies stuff from C structure.)
  */
 uniform sampler1D curve_mapping_texture;
 uniform int curve_mapping_lut_size;
@@ -141,9 +141,44 @@ vec4 apply_dither(vec2 st, vec4 col)
 }
 #endif
 
+#ifdef USE_TONEMAP
+/* The inverse of the squared white value parameter */
+uniform float white_inv_sqr;
+
+vec4 apply_tonemap(vec4 col)
+{
+	vec4 result;
+	result[0] = col[0] * (1 + col[0] * white_inv_sqr) / (1 + col[0]);
+	result[1] = col[1] * (1 + col[1] * white_inv_sqr) / (1 + col[1]);
+	result[2] = col[2] * (1 + col[2] * white_inv_sqr) / (1 + col[2]);
+	result[3] = col[3];
+	return result;
+}
+#endif
+
+#ifdef USE_EXPOSURE
+uniform float gain;
+
+vec4 apply_exposure(vec4 col)
+{
+	vec4 result;
+	result[0] = col[0] * gain;
+	result[1] = col[1] * gain;
+	result[2] = col[2] * gain;
+	result[3] = col[3];
+	return result;
+}
+#endif
+
 void main()
 {
 	vec4 col = texture2D(image_texture, gl_TexCoord[0].st);
+#ifdef USE_EXPOSURE
+	col = apply_exposure(col);
+#endif
+#ifdef USE_TONEMAP
+	col = apply_tonemap(col);
+#endif
 #ifdef USE_CURVE_MAPPING
 	col = curvemapping_evaluate_premulRGBF(col);
 #endif
diff --git a/intern/opencolorio/ocio_capi.cc b/intern/opencolorio/ocio_capi.cc
index a4f2db4..4aa78eb 100644
--- a/intern/opencolorio/ocio_capi.cc
+++ b/intern/opencolorio/ocio_capi.cc
@@ -324,9 +324,10 @@ int OCIO_supportGLSLDraw(void)
 }
 
 int OCIO_setupGLSLDraw(struct OCIO_GLSLDrawState **state_r, OCIO_ConstProcessorRcPtr *processor,
-                       OCIO_CurveMappingSettings *curve_mapping_settings, float dither, bool predivide)
+                       OCIO_CurveMappingSettings *curve_mapping_settings, float dither,
+                       float white_value, float exposure, bool predivide)
 {
-	return (int) impl->setupGLSLDraw(state_r, processor, curve_mapping_settings, dither, predivide);
+	return (int) impl->setupGLSLDraw(state_r, processor, curve_mapping_settings, dither, white_value, exposure, predivide);
 }
 
 void OCIO_finishGLSLDraw(struct OCIO_GLSLDrawState *state)
diff --git a/intern/opencolorio/ocio_capi.h b/intern/opencolorio/ocio_capi.h
index d667dec..b44d136 100644
--- a/intern/opencolorio/ocio_capi.h
+++ b/intern/opencolorio/ocio_capi.h
@@ -189,7 +189,8 @@ void OCIO_matrixTransformScale(float *m44, float *offset4, const float *scale4);
 
 int OCIO_supportGLSLDraw(void);
 int OCIO_setupGLSLDraw(struct OCIO_GLSLDrawState **state_r, OCIO_ConstProcessorRcPtr *processor,
-                       OCIO_CurveMappingSettings *curve_mapping_settings, float dither, bool predivide);
+                       OCIO_CurveMappingSettings *curve_mapping_settings, float dither,
+                       float white_value, float exposure, bool predivide);
 void OCIO_finishGLSLDraw(struct OCIO_GLSLDrawState *state);
 void OCIO_freeOGLState(struct OCIO_GLSLDrawState *state);
 
diff --git a/intern/opencolorio/ocio_impl.h b/intern/opencolorio/ocio_impl.h
index 47e6d82..6651029 100644
--- a/intern/opencolorio/ocio_impl.h
+++ b/intern/opencolorio/ocio_impl.h
@@ -107,7 +107,8 @@ public:
 
 	virtual bool supportGLSLDraw(void) = 0;
 	virtual bool setupGLSLDraw(struct OCIO_GLSLDrawState **state_r, OCIO_ConstProcessorRcPtr *processor,
-	                           OCIO_CurveMappingSettings *curve_mapping_settings, float dither, bool predivide) = 0;
+	                           OCIO_CurveMappingSettings *curve_mapping_settings, float dither,
+	                           float white_value, float exposure, bool predivide) = 0;
 	virtual void finishGLSLDraw(struct OCIO_GLSLDrawState *state) = 0;
 	virtual void freeGLState(struct OCIO_GLSLDrawState *state_r) = 0;
 
@@ -194,7 +195,8 @@ public:
 
 	bool supportGLSLDraw(void);
 	bool setupGLSLDraw(struct OCIO_GLSLDrawState **state_r, OCIO_ConstProcessorRcPtr *processor,
-	                   OCIO_CurveMappingSettings *curve_mapping_settings, float dither, bool predivide);
+	                   OCIO_CurveMappingSettings *curve_mapping_settings, float dither,
+					   float white_value, float exposure, bool predivide);
 	void finishGLSLDraw(struct OCIO_GLSLDrawState *state);
 	void freeGLState(struct OCIO_GLSLDrawState *state_r);
 
@@ -282,7 +284,8 @@ public:
 
 	bool supportGLSLDraw(void);
 	bool setupGLSLDraw(struct OCIO_GLSLDrawState **state_r, OCIO_ConstProcessorRcPtr *processor,
-	                   OCIO_CurveMappingSettings *curve_mapping_settings, float dither, bool predivide);
+	                   OCIO_CurveMappingSettings *curve_mapping_settings, float dither,
+					   float white_value, float exposure, bool predivide);
 	void finishGLSLDraw(struct OCIO_GLSLDrawState *state);
 	void freeGLState(struct OCIO_GLSLDrawState *state_r);
 
diff --git a/intern/opencolorio/ocio_impl_glsl.cc b/intern/opencolorio/ocio_impl_glsl.cc
index de89ea7..9347b36 100644
--- a/intern/opencolorio/ocio_impl_glsl.cc
+++ b/intern/opencolorio/ocio_impl_glsl.cc
@@ -64,6 +64,8 @@ typedef struct OCIO_GLSLDrawState {
 	float *lut3d;  /* 3D LUT table */
 
 	bool dither_used;
+	bool exposure_used;
+	bool tonemap_used;
 
 	bool curve_mapping_used;
 	bool curve_mapping_texture_allocated;
@@ -248,11 +250,13 @@ static bool supportGLSL13()
  */
 bool OCIOImpl::setupGLSLDraw(OCIO_GLSLDrawState **state_r, OCIO_ConstProcessorRcPtr *processor,
                              OCIO_CurveMappingSettings *curve_mapping_settings,
-                             float dither, bool use_predivide)
+							 float dither, float white_value, float exposure, bool use_predivide)
 {
 	ConstProcessorRcPtr ocio_processor = *(ConstProcessorRcPtr *) processor;
 	bool use_curve_mapping = curve_mapping_settings != NULL;
 	bool use_dither = dither > std::numeric_limits<float>::epsilon();
+	bool use_tonemap = fabsf(white_value) > std::numeric_limits<float>::epsilon();
+	bool use_exposure = fabsf(exposure) > std::numeric_limits<float>::epsilon();
 
 	/* Create state if needed. */
 	OCIO_GLSLDrawState *state;
@@ -319,7 +323,9 @@ bool OCIOImpl::setupGLSLDraw(OCIO_GLSLDrawState **state_r, OCIO_ConstProcessorRc
 	    shaderCacheID != state->shadercacheid ||
 	    use_predivide != state->predivide_used ||
 	    use_curve_mapping != state->curve_mapping_used ||
-	    use_dither != state->dither_used)
+	    use_dither != state->dither_used ||
+	    use_tonemap != state->tonemap_used ||
+	    use_exposure != state->exposure_used)
 	{
 		state->shadercacheid = shaderCacheID;
 
@@ -353,6 +359,14 @@ bool OCIOImpl::setupGLSLDraw(OCIO_GLSLDrawState **state_r, OCIO_ConstProcessorRc
 			os << "#define USE_CURVE_MAPPING\n";
 		}
 
+		if (use_tonemap) {
+			os << "#define USE_TONEMAP\n";
+		}
+
+		if (use_exposure) {
+			os << "#define USE_EXPOSURE\n";
+		}
+
 		os << ocio_processor->getGpuShaderText(shaderDesc) << "\n";
 		os << datatoc_gpu_shader_display_transform_glsl;
 
@@ -364,7 +378,9 @@ bool OCIOImpl::setupGLSLDraw(OCIO_GLSLDrawState **state_r, OCIO_ConstProcessorRc
 
 		state->curve_mapping_used = use_curve_mapping;
 		state->dither_used = use_dither;
+		state->tonemap_used = use_tonemap;
 		state->predivide_used = use_predivide;
+		state->exposure_used = use_exposure;
 	}
 
 	if (state->program) {
@@ -399,6 +415,14 @@ bool OCIOImpl::setupGLSLDraw(OCIO_GLSLDrawState **state_r, OCIO_ConstProcessorRc
 			glUniform1f(glGetUniformLocation(state->program, "dither"), dither);
 		}
 
+		if (use_tonemap) {
+			glUniform1f(glGetUniformLocation(state->program, "white_inv_sqr"), powf(2.0f, -2.0f*white_value));
+		}
+
+		if (use_exposure) {
+			glUniform1f(glGetUniformLocation(state->program, "gain"), powf(2.0f, exposure));
+		}
+
 		if (use_curve_mapping) {
 			glUniform1i(glGetUniformLocation(state->program, "curve_mapping_texture"), 2);
 			glUniform1i(glGetUniformLocation(state->program, "curve_mapping_lut_size"), curve_mapping_settings->lut_size);
diff --git a/release/scripts/startup/nodeitems_builtins.py b/release/scripts/startup/nodeitems_builtins.py
index 1590bd4..2118a06 100644
--- a/release/scripts/startup/nodeitems_builtins.py
+++ b/release/scripts/startup/nodeitems_builtins.py
@@ -219,6 +219,7 @@ shader_node_categories = [
         NodeItem("ShaderNodeBackground", poll=world_shader_nodes_poll),
         NodeItem("ShaderNodeAmbientOcclusion", poll=object_shader_nodes_poll),
         NodeItem("ShaderNodeHoldout", poll=object_shader_nodes_poll),
+        NodeItem("ShaderNodeShadowCatcher", poll=object_shader_nodes_poll),
         NodeItem("ShaderNodeVolumeAbsorption"),
         NodeItem("ShaderNodeVolumeScatter"),
         ]),
diff --git a/source/blender/blenkernel/BKE_node.h b/source/blender/blenkernel/BKE_node.h
index 44ac3b7..73ad729 100644
--- a/source/blender/blenkernel/BKE_node.h
+++ b/source/blender/blenkernel/BKE_node.h
@@ -787,6 +787,7 @@ struct ShadeResult;
 #define SH_NODE_COMBXYZ					189
 #define SH_NODE_OUTPUT_LINESTYLE		190
 #define SH_NODE_UVALONGSTROKE			191
+#define SH_NODE_SHADOW_CATCHER				192
 
 /* custom defines options for Material node */
 #define SH_NODE_MAT_DIFF   1
diff --git a/source/blender/blenkernel/intern/colortools.c b/source/blender/blenkernel/intern/colortools.c
index 89c3e4b..ca34445 100644
--- a/source/blender/blenkernel/intern/colortools.c
+++ b/source/blender/blenkernel/intern/colortools.c
@@ -1269,6 +1269,7 @@ void BKE_color_managed_view_settings_init(ColorManagedViewSettings *settings)
 
 	settings->gamma = 1.0f;
 	settings->exposure = 0.0f;
+	settings->white_value = 0.0f;
 }
 
 void BKE_color_managed_view_settings_copy(ColorManagedViewSettings *new_settings,
@@ -1280,6 +1281,7 @@ void BKE_color_managed_view_settings_copy(ColorManagedViewSettings *new_settings
 	new_settings->flag = settings->flag;
 	new_settings->exposure = settings->exposure;
 	new_settings->gamma = settings->gamma;
+	new_settings->white_value = settings->white_value;
 
 	if (settings->curve_mapping)
 		new_settings->curve_mapping = curvemapping_copy(settings->curve_mapping);
diff --git a/source/blender/blenkernel/intern/node.c b/source/blender/blenkernel/intern/node.c
index c7010e4..35d8c4da 100644
--- a/source/blender/blenkernel/intern/node.c
+++ b/source/blender/blenkernel/intern/node.c
@@ -3544,6 +3544,7 @@ static void registerShaderNodes(void)
 	register_node_type_sh_bsdf_hair();
 	register_node_type_sh_emission();
 	register_node_type_sh_holdout();
+	register_node_type_sh_shadow_catcher();
 	register_node_type_sh_volume_absorption();
 	register_node_type_sh_volume_scatter();
 	register_node_type_sh_subsurface_scattering();
diff --git a/source/blender/editors/interface/interface_templates.c b/source/blender/editors/interface/interface_templates.c
index b3c31a1..33c5a75 100644
--- a/source/blender/editors/interface/interface_templates.c
+++ b/source/blender/editors/interface/interface_templates.c
@@ -3622,6 +3622,7 @@ void uiTemplateColormanagedViewSettings(uiLayout *layout, bContext *UNUSED(C), P
 	col = uiLayoutColumn(layout, false);
 	uiItemR(col, &view_transform_ptr, "exposure", 0, NULL, ICON_NONE);
 	uiItemR(col, &view_transform_ptr, "gamma", 0, NULL, ICON_NONE);
+	uiItemR(col, &view_transform_ptr, "white_value", 0, NULL, ICON_NONE);
 
 	uiItemR(col, &view_transform_ptr, "look", 0, IFACE_("Look"), ICON_NONE);
 
diff --git a/source/blender/imbuf/intern/colormanagement.c b/source/blender/imbuf/intern/colormanagement.c
index 95e166b..4df4e3f 100644
--- a/source/blender/imbuf/intern/colormanagement.c
+++ b/source/blender/imbuf/intern/colormanagement.c
@@ -100,6 +100,8 @@ static pthread_mutex_t processor_lock = BLI_MUTEX_INITIALIZER;
 typedef struct ColormanageProcessor {
 	OCIO_ConstProcessorRcPtr *processor;
 	CurveMapping *curve_mapping;
+	float white_inv_sqr;
+	float gain;
 	bool is_data_result;
 } ColormanageProcessor;
 
@@ -118,6 +120,7 @@ static struct global_glsl_state {
 	bool use_curve_mapping;
 	int curve_mapping_timestamp;
 	OCIO_CurveMappingSettings curve_mapping_settings;
+	float white_value;
 
 	/* Container for GLSL state needed for OCIO module. */
 	struct OCIO_GLSLDrawState *ocio_glsl_state;
@@ -198,6 +201,7 @@ typedef struct ColormanageCacheViewSettings {
 	float gamma;
 	float dither;
 	CurveMapping *curve_mapping;
+	float white_value;
 } ColormanageCacheViewSettings;
 
 typedef struct ColormanageCacheDisplaySettings {
@@ -209,7 +213,7 @@ typedef struct ColormanageCacheKey {
 	int display;         /* display device name */
 } ColormanageCacheKey;
 
-typedef struct ColormnaageCacheData {
+typedef struct ColormanageCacheData {
 	int flag;        /* view flags of cached buffer */
 	int look;        /* Additional artistics transform */
 	float exposure;  /* exposure value cached buffer is calculated with */
@@ -217,12 +221,13 @@ typedef struct ColormnaageCacheData {
 	float dither;    /* dither value cached buffer is calculated with */
 	CurveMapping *curve_mapping;  /* curve mapping used for cached buffer */
 	int curve_mapping_timestamp;  /* time stamp of curve mapping used for cached buffer */
-} ColormnaageCacheData;
+	float white_value;    /* white value the cached buffer is calculated with */
+} ColormanageCacheData;
 
 typedef struct ColormanageCache {
 	struct MovieCache *moviecache;
 
-	ColormnaageCacheData *data;
+	ColormanageCacheData *data;
 } ColormanageCache;
 
 static struct MovieCache *colormanage_moviecache_get(const ImBuf *ibuf)
@@ -233,7 +238,7 @@ static struct MovieCache *colormanage_moviecache_get(const ImBuf *ibuf)
 	return ibuf->colormanage_cache->moviecache;
 }
 
-static ColormnaageCacheData *colormanage_cachedata_get(const ImBuf *ibuf)
+static ColormanageCacheData *colormanage_cachedata_get(const ImBuf *ibuf)
 {
 	if (!ibuf->colormanage_cache)
 		return NULL;
@@ -276,7 +281,7 @@ static struct MovieCache *colormanage_moviecache_ensure(ImBuf *ibuf)
 	return ibuf->colormanage_cache->moviecache;
 }
 
-static void colormanage_cachedata_set(ImBuf *ibuf, ColormnaageCacheData *data)
+static void colormanage_cachedata_set(ImBuf *ibuf, ColormanageCacheData *data)
 {
 	if (!ibuf->colormanage_cache)
 		ibuf->colormanage_cache = MEM_callocN(sizeof(ColormanageCache), "imbuf colormanage cache");
@@ -296,6 +301,7 @@ static void colormanage_view_settings_to_cache(ImBuf *ibuf,
 	cache_view_settings->exposure = view_settings->exposure;
 	cache_view_settings->gamma = view_settings->gamma;
 	cache_view_settings->dither = ibuf->dither;
+	cache_view_settings->white_value = view_settings->white_value;
 	cache_view_settings->flag = view_settings->flag;
 	cache_view_settings->curve_mapping = view_settings->curve_mapping;
 }
@@ -356,7 +362,7 @@ static unsigned char *colormanage_cache_get(ImBuf *ibuf, const ColormanageCacheV
 	cache_ibuf = colormanage_cache_get_ibuf(ibuf, &key, cache_handle);
 
 	if (cache_ibuf) {
-		ColormnaageCacheData *cache_data;
+		ColormanageCacheData *cache_data;
 
 		BLI_assert(cache_ibuf->x == ibuf->x &&
 		           cache_ibuf->y == ibuf->y);
@@ -374,6 +380,7 @@ static unsigned char *colormanage_cache_get(ImBuf *ibuf, const ColormanageCacheV
 		    cache_data->exposure != view_settings->exposure ||
 		    cache_data->gamma != view_settings->gamma ||
 		    cache_data->dither != view_settings->dither ||
+			cache_data->white_value != view_settings->white_value ||
 		    cache_data->flag != view_settings->flag ||
 		    cache_data->curve_mapping != curve_mapping ||
 		    cache_data->curve_mapping_timestamp != curve_mapping_timestamp)
@@ -397,7 +404,7 @@ static void colormanage_cache_put(ImBuf *ibuf, const ColormanageCacheViewSetting
 {
 	ColormanageCacheKey key;
 	ImBuf *cache_ibuf;
-	ColormnaageCacheData *cache_data;
+	ColormanageCacheData *cache_data;
 	int view_flag = 1 << (view_settings->view - 1);
 	struct MovieCache *moviecache = colormanage_moviecache_ensure(ibuf);
 	CurveMapping *curve_mapping = view_settings->curve_mapping;
@@ -416,11 +423,12 @@ static void colormanage_cache_put(ImBuf *ibuf, const ColormanageCacheViewSetting
 	cache_ibuf->flags |= IB_rect;
 
 	/* store data which is needed to check whether cached buffer could be used for color managed display settings */
-	cache_data = MEM_callocN(sizeof(ColormnaageCacheData), "color manage cache imbuf data");
+	cache_data = MEM_callocN(sizeof(ColormanageCacheData), "color manage cache imbuf data");
 	cache_data->look = view_settings->look;
 	cache_data->exposure = view_settings->exposure;
 	cache_data->gamma = view_settings->gamma;
 	cache_data->dither = view_settings->dither;
+	cache_data->white_value = view_settings->white_value;
 	cache_data->flag = view_settings->flag;
 	cache_data->curve_mapping = curve_mapping;
 	cache_data->curve_mapping_timestamp = curve_mapping_timestamp;
@@ -702,7 +710,7 @@ void colormanage_cache_free(ImBuf *ibuf)
 	}
 
 	if (ibuf->colormanage_cache) {
-		ColormnaageCacheData *cache_data = colormanage_cachedata_get(ibuf);
+		ColormanageCacheData *cache_data = colormanage_cachedata_get(ibuf);
 		struct MovieCache *moviecache = colormanage_moviecache_get(ibuf);
 
 		if (cache_data) {
@@ -765,7 +773,7 @@ static ColorSpace *display_transform_get_colorspace(const ColorManagedViewSettin
 static OCIO_ConstProcessorRcPtr *create_display_buffer_processor(const char *look,
                                                                  const char *view_transform,
                                                                  const char *display,
-                                                                 float exposure, float gamma,
+                                                                 float gamma,
                                                                  const char *from_colorspace)
 {
 	OCIO_ConstConfigRcPtr *config = OCIO_getCurrentConfig();
@@ -784,21 +792,6 @@ static OCIO_ConstProcessorRcPtr *create_display_buffer_processor(const char *loo
 		OCIO_displayTransformSetLooksOverride(dt, look);
 	}
 
-	/* fstop exposure control */
-	if (exposure != 0.0f) {
-		OCIO_MatrixTransformRcPtr *mt;
-		float gain = powf(2.0f, exposure);
-		const float scale4f[] = {gain, gain, gain, 1.0f};
-		float m44[16], offset4[4];
-
-		OCIO_matrixTransformScale(m44, offset4, scale4f);
-		mt = OCIO_createMatrixTransform();
-		OCIO_matrixTransformSetValue(mt, m44, offset4);
-		OCIO_displayTransformSetLinearCC(dt, (OCIO_ConstTransformRcPtr *) mt);
-
-		OCIO_matrixTransformRelease(mt);
-	}
-
 	/* post-display gamma transform */
 	if (gamma != 1.0f) {
 		OCIO_ExponentTransformRcPtr *et;
@@ -939,6 +932,7 @@ static void init_default_view_settings(const ColorManagedDisplaySettings *displa
 	view_settings->flag = 0;
 	view_settings->gamma = 1.0f;
 	view_settings->exposure = 0.0f;
+	view_settings->white_value = 0.0f;
 	view_settings->curve_mapping = NULL;
 }
 
@@ -956,6 +950,37 @@ static void curve_mapping_apply_pixel(CurveMapping *curve_mapping, float *pixel,
 	}
 }
 
+static void tonemap_apply_pixel(float white_value_inv_sqr, float *pixel, int channels)
+{
+	if (channels == 1) {
+		pixel[0] = pixel[0] * (1.0f + pixel[0] * white_value_inv_sqr) / (1.0f + pixel[0]);
+	}
+	else if (channels == 2) {
+		pixel[0] = pixel[0] * (1.0f + pixel[0] * white_value_inv_sqr) / (1.0f + pixel[0]);
+		pixel[1] = pixel[1] * (1.0f + pixel[1] * white_value_inv_sqr) / (1.0f + pixel[1]);
+	}
+	else {
+		pixel[0] = pixel[0] * (1.0f + pixel[0] * white_value_inv_sqr) / (1.0f + pixel[0]);
+		pixel[1] = pixel[1] * (1.0f + pixel[1] * white_value_inv_sqr) / (1.0f + pixel[1]);
+		pixel[2] = pixel[2] * (1.0f + pixel[2] * white_value_inv_sqr) / (1.0f + pixel[2]);
+	}
+}
+
+static void exposure_apply_pixel(float gain, float *pixel, int channels) {
+	if (channels == 1) {
+		pixel[0] *= gain;
+	}
+	else if (channels == 2) {
+		pixel[0] *= gain;
+		pixel[1] *= gain;
+	}
+	else {
+		pixel[0] *= gain;
+		pixel[1] *= gain;
+		pixel[2] *= gain;
+	}
+}
+
 void colorspace_set_default_role(char *colorspace, int size, int role)
 {
 	if (colorspace && colorspace[0] == '\0') {
@@ -1064,6 +1089,7 @@ static void colormanage_check_view_settings(ColorManagedDisplaySettings *display
 	if (view_settings->exposure == 0.0f && view_settings->gamma == 0.0f) {
 		view_settings->exposure = 0.0f;
 		view_settings->gamma = 1.0f;
+		view_settings->white_value = 0.0f;
 	}
 }
 
@@ -1491,7 +1517,8 @@ static bool is_ibuf_rect_in_display_space(ImBuf *ibuf, const ColorManagedViewSet
 {
 	if ((view_settings->flag & COLORMANAGE_VIEW_USE_CURVES) == 0 &&
 	    view_settings->exposure == 0.0f &&
-	    view_settings->gamma == 1.0f)
+	    view_settings->gamma == 1.0f &&
+	    view_settings->white_value == 0.0f)
 	{
 		const char *from_colorspace = ibuf->rect_colorspace->name;
 		const char *to_colorspace = IMB_colormanagement_get_display_colorspace_name(view_settings, display_settings);
@@ -2842,7 +2869,6 @@ ColormanageProcessor *IMB_colormanagement_display_processor_new(const ColorManag
 	cm_processor->processor = create_display_buffer_processor(applied_view_settings->look,
 	                                                          applied_view_settings->view_transform,
 	                                                          display_settings->display_device,
-	                                                          applied_view_settings->exposure,
 	                                                          applied_view_settings->gamma,
 	                                                          global_role_scene_linear);
 
@@ -2850,6 +2876,16 @@ ColormanageProcessor *IMB_colormanagement_display_processor_new(const ColorManag
 		cm_processor->curve_mapping = curvemapping_copy(applied_view_settings->curve_mapping);
 		curvemapping_premultiply(cm_processor->curve_mapping, false);
 	}
+	
+	if (applied_view_settings->exposure == 0.0f)
+		cm_processor->gain = 1.0f;
+	else
+		cm_processor->gain = powf(2.0f, applied_view_settings->exposure);
+
+	if (applied_view_settings->white_value == 0.0f)
+		cm_processor->white_inv_sqr = 1.0f;
+	else
+		cm_processor->white_inv_sqr = powf(2.0f, -2.0f * applied_view_settings->white_value);
 
 	return cm_processor;
 }
@@ -2871,6 +2907,12 @@ ColormanageProcessor *IMB_colormanagement_colorspace_processor_new(const char *f
 
 void IMB_colormanagement_processor_apply_v4(ColormanageProcessor *cm_processor, float pixel[4])
 {
+	if (cm_processor->gain != 1.0f)
+		exposure_apply_pixel(cm_processor->gain, pixel, 3);
+
+	if (cm_processor->white_inv_sqr != 1.0f)
+		tonemap_apply_pixel(cm_processor->white_inv_sqr, pixel, 3);
+
 	if (cm_processor->curve_mapping)
 		curvemapping_evaluate_premulRGBF(cm_processor->curve_mapping, pixel, pixel);
 
@@ -2880,6 +2922,12 @@ void IMB_colormanagement_processor_apply_v4(ColormanageProcessor *cm_processor,
 
 void IMB_colormanagement_processor_apply_v4_predivide(ColormanageProcessor *cm_processor, float pixel[4])
 {
+	if (cm_processor->gain != 1.0f)
+		exposure_apply_pixel(cm_processor->gain, pixel, 3);
+
+	if (cm_processor->white_inv_sqr != 1.0f)
+		tonemap_apply_pixel(cm_processor->white_inv_sqr, pixel, 3);
+	
 	if (cm_processor->curve_mapping)
 		curvemapping_evaluate_premulRGBF(cm_processor->curve_mapping, pixel, pixel);
 
@@ -2889,6 +2937,12 @@ void IMB_colormanagement_processor_apply_v4_predivide(ColormanageProcessor *cm_p
 
 void IMB_colormanagement_processor_apply_v3(ColormanageProcessor *cm_processor, float pixel[3])
 {
+	if (cm_processor->gain != 1.0f)
+		exposure_apply_pixel(cm_processor->gain, pixel, 3);
+
+	if (cm_processor->white_inv_sqr != 1.0f)
+		tonemap_apply_pixel(cm_processor->white_inv_sqr, pixel, 3);
+	
 	if (cm_processor->curve_mapping)
 		curvemapping_evaluate_premulRGBF(cm_processor->curve_mapping, pixel, pixel);
 
@@ -2905,6 +2959,13 @@ void IMB_colormanagement_processor_apply_pixel(struct ColormanageProcessor *cm_p
 		IMB_colormanagement_processor_apply_v3(cm_processor, pixel);
 	}
 	else if (channels == 1) {
+		if (cm_processor->gain != 1.0f) {
+			exposure_apply_pixel(cm_processor->gain, pixel, 3);
+		}
+
+		if (cm_processor->white_inv_sqr != 1.0f) {
+			tonemap_apply_pixel(cm_processor->white_inv_sqr, pixel, 1);
+		}
 		if (cm_processor->curve_mapping) {
 			curve_mapping_apply_pixel(cm_processor->curve_mapping, pixel, 1);
 		}
@@ -2917,6 +2978,31 @@ void IMB_colormanagement_processor_apply_pixel(struct ColormanageProcessor *cm_p
 void IMB_colormanagement_processor_apply(ColormanageProcessor *cm_processor, float *buffer, int width, int height,
                                          int channels, bool predivide)
 {
+	/* apply exposure*/
+	if (cm_processor->gain != 1.0f) {
+		int x, y;
+
+		for (y = 0; y < height; y++) {
+			for (x = 0; x < width; x++) {
+				float *pixel = buffer + channels * (y * width + x);
+
+				exposure_apply_pixel(cm_processor->gain, pixel, channels);
+			}
+		}
+	}
+	/* apply tonemapping*/
+	if (cm_processor->white_inv_sqr != 1.0f) {
+		int x, y;
+
+		for (y = 0; y < height; y++) {
+			for (x = 0; x < width; x++) {
+				float *pixel = buffer + channels * (y * width + x);
+
+				tonemap_apply_pixel(cm_processor->white_inv_sqr, pixel, channels);
+			}
+		}
+	}
+	
 	/* apply curve mapping */
 	if (cm_processor->curve_mapping) {
 		int x, y;
@@ -3032,6 +3118,7 @@ static void update_glsl_display_processor(const ColorManagedViewSettings *view_s
 		BLI_strncpy(global_glsl_state.input, from_colorspace, MAX_COLORSPACE_NAME);
 		global_glsl_state.exposure = view_settings->exposure;
 		global_glsl_state.gamma = view_settings->gamma;
+		global_glsl_state.white_value = view_settings->white_value;
 
 		/* We're using curve mapping's address as a cache ID,
 		 * so we need to make sure re-allocation gives new address here.
@@ -3071,7 +3158,6 @@ static void update_glsl_display_processor(const ColorManagedViewSettings *view_s
 			create_display_buffer_processor(global_glsl_state.look,
 			                                global_glsl_state.view,
 			                                global_glsl_state.display,
-			                                global_glsl_state.exposure,
 			                                global_glsl_state.gamma,
 			                                global_glsl_state.input);
 	}
@@ -3121,7 +3207,7 @@ bool IMB_colormanagement_setup_glsl_draw_from_space(const ColorManagedViewSettin
 
 	return OCIO_setupGLSLDraw(&global_glsl_state.ocio_glsl_state, global_glsl_state.processor,
 	                          global_glsl_state.use_curve_mapping ? &global_glsl_state.curve_mapping_settings : NULL,
-	                          dither, predivide);
+							  dither, view_settings->white_value, view_settings->exposure, predivide);
 }
 
 /* Configures GLSL shader for conversion from scene linear to display space */
diff --git a/source/blender/makesdna/DNA_color_types.h b/source/blender/makesdna/DNA_color_types.h
index e373112..f22d485 100644
--- a/source/blender/makesdna/DNA_color_types.h
+++ b/source/blender/makesdna/DNA_color_types.h
@@ -169,6 +169,8 @@ typedef struct ColorManagedViewSettings {
 	char view_transform[64];   /* view transform which is being applied when displaying buffer on the screen */
 	float exposure;            /* fstop exposure */
 	float gamma;               /* post-display gamma transform */
+	float white_value; /* tonemapping parameter */
+	float pad3;
 	struct CurveMapping *curve_mapping;  /* pre-display RGB curves transform */
 	void *pad2;
 } ColorManagedViewSettings;
diff --git a/source/blender/makesrna/intern/rna_color.c b/source/blender/makesrna/intern/rna_color.c
index 5e114a5..2b44fbf 100644
--- a/source/blender/makesrna/intern/rna_color.c
+++ b/source/blender/makesrna/intern/rna_color.c
@@ -1140,6 +1140,13 @@ static void rna_def_colormanage(BlenderRNA *brna)
 	RNA_def_property_ui_text(prop, "Gamma", "Amount of gamma modification applied after display transform");
 	RNA_def_property_update(prop, NC_WINDOW, "rna_ColorManagement_update");
 
+	prop = RNA_def_property(srna, "white_value", PROP_FLOAT, PROP_FACTOR);
+	RNA_def_property_float_sdna(prop, NULL, "white_value");
+	RNA_def_property_range(prop, 0.0f, 10.0f);
+	RNA_def_property_float_default(prop, 0.0f);
+	RNA_def_property_ui_text(prop, "White Value", "The brightness that is mapped to white by the tonemapper, in f-stops (0 disables tonemapping)");
+	RNA_def_property_update(prop, NC_WINDOW, "rna_ColorManagement_update");
+
 	prop = RNA_def_property(srna, "curve_mapping", PROP_POINTER, PROP_NONE);
 	RNA_def_property_pointer_sdna(prop, NULL, "curve_mapping");
 	RNA_def_property_ui_text(prop, "Curve", "Color curve mapping applied before display transform");
diff --git a/source/blender/makesrna/intern/rna_render.c b/source/blender/makesrna/intern/rna_render.c
index 124a83a..b4d2ff3 100644
--- a/source/blender/makesrna/intern/rna_render.c
+++ b/source/blender/makesrna/intern/rna_render.c
@@ -696,6 +696,9 @@ static void rna_def_render_pass(BlenderRNA *brna)
 
 	static EnumPropertyItem render_pass_debug_type_items[] = {
 		{RENDER_PASS_DEBUG_BVH_TRAVERSAL_STEPS, "BVH_TRAVERSAL_STEPS", 0, "BVH Traversal Steps", ""},
+		{RENDER_PASS_DEBUG_SAMPLES, "SAMPLES", 0, "Number of samples", ""},
+		{RENDER_PASS_DEBUG_VARIANCE, "VARIANCE", 0, "Pixel variance", ""},
+		{RENDER_PASS_DEBUG_IMPORTANCE, "IMPORTANCE", 0, "Pixel importance", ""},
 		{0, NULL, 0, NULL, NULL}
 	};
 
diff --git a/source/blender/nodes/CMakeLists.txt b/source/blender/nodes/CMakeLists.txt
index 9eb6c16..0476134 100644
--- a/source/blender/nodes/CMakeLists.txt
+++ b/source/blender/nodes/CMakeLists.txt
@@ -175,6 +175,7 @@ set(SRC
 	shader/nodes/node_shader_fresnel.c
 	shader/nodes/node_shader_geometry.c
 	shader/nodes/node_shader_holdout.c
+	shader/nodes/node_shader_shadow_catcher.c
 	shader/nodes/node_shader_layer_weight.c
 	shader/nodes/node_shader_light_falloff.c
 	shader/nodes/node_shader_light_path.c
diff --git a/source/blender/nodes/NOD_shader.h b/source/blender/nodes/NOD_shader.h
index 595a3b1..6963a88 100644
--- a/source/blender/nodes/NOD_shader.h
+++ b/source/blender/nodes/NOD_shader.h
@@ -107,6 +107,7 @@ void register_node_type_sh_bsdf_toon(void);
 void register_node_type_sh_bsdf_anisotropic(void);
 void register_node_type_sh_emission(void);
 void register_node_type_sh_holdout(void);
+void register_node_type_sh_shadow_catcher(void);
 void register_node_type_sh_volume_absorption(void);
 void register_node_type_sh_volume_scatter(void);
 void register_node_type_sh_bsdf_hair(void);
diff --git a/source/blender/nodes/NOD_static_types.h b/source/blender/nodes/NOD_static_types.h
index 166fa29..f7b312b 100644
--- a/source/blender/nodes/NOD_static_types.h
+++ b/source/blender/nodes/NOD_static_types.h
@@ -78,6 +78,7 @@ DefNode( ShaderNode,     SH_NODE_ATTRIBUTE,          def_sh_attribute,       "AT
 DefNode( ShaderNode,     SH_NODE_AMBIENT_OCCLUSION,  0,                      "AMBIENT_OCCLUSION",  AmbientOcclusion, "Ambient Occlusion", ""       )
 DefNode( ShaderNode,     SH_NODE_BACKGROUND,         0,                      "BACKGROUND",         Background,       "Background",        ""       )
 DefNode( ShaderNode,     SH_NODE_HOLDOUT,            0,                      "HOLDOUT",            Holdout,          "Holdout",           ""       )
+DefNode( ShaderNode,     SH_NODE_SHADOW_CATCHER,     0,                      "SHADOW_CATCHER",     ShadowCatcher,    "Shadow Catcher",    ""       )
 DefNode( ShaderNode,     SH_NODE_BSDF_ANISOTROPIC,   def_anisotropic,        "BSDF_ANISOTROPIC",   BsdfAnisotropic,  "Anisotropic BSDF",  ""       )
 DefNode( ShaderNode,     SH_NODE_BSDF_DIFFUSE,       0,                      "BSDF_DIFFUSE",       BsdfDiffuse,      "Diffuse BSDF",      ""       )
 DefNode( ShaderNode,     SH_NODE_BSDF_GLOSSY,        def_glossy,             "BSDF_GLOSSY",        BsdfGlossy,       "Glossy BSDF",       ""       )
diff --git a/source/blender/nodes/shader/nodes/node_shader_shadow_catcher.c b/source/blender/nodes/shader/nodes/node_shader_shadow_catcher.c
new file mode 100644
index 0000000..7fb99e8
--- /dev/null
+++ b/source/blender/nodes/shader/nodes/node_shader_shadow_catcher.c
@@ -0,0 +1,54 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) 2005 Blender Foundation.
+ * All rights reserved.
+ *
+ * The Original Code is: all of this file.
+ *
+ * Contributor(s): none yet.
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+#include "../node_shader_util.h"
+
+/* **************** OUTPUT ******************** */
+
+static bNodeSocketTemplate sh_node_shadow_catcher_in[] = {
+	{	-1, 0, ""	}
+};
+
+static bNodeSocketTemplate sh_node_shadow_catcher_out[] = {
+	{	SOCK_SHADER, 0, N_("ShadowCatcher")},
+	{	-1, 0, ""	}
+};
+
+
+/* node type definition */
+void register_node_type_sh_shadow_catcher(void)
+{
+	static bNodeType ntype;
+
+	sh_node_type_base(&ntype, SH_NODE_SHADOW_CATCHER, "ShadowCatcher", NODE_CLASS_SHADER, 0);
+	node_type_compatibility(&ntype, NODE_NEW_SHADING);
+	node_type_socket_templates(&ntype, sh_node_shadow_catcher_in, sh_node_shadow_catcher_out);
+	node_type_init(&ntype, NULL);
+	node_type_storage(&ntype, "", NULL, NULL);
+
+	nodeRegisterType(&ntype);
+}
diff --git a/source/blender/render/extern/include/RE_pipeline.h b/source/blender/render/extern/include/RE_pipeline.h
index d1b6673..cc418cf 100644
--- a/source/blender/render/extern/include/RE_pipeline.h
+++ b/source/blender/render/extern/include/RE_pipeline.h
@@ -77,6 +77,9 @@ typedef struct RenderPass {
 
 enum {
 	RENDER_PASS_DEBUG_BVH_TRAVERSAL_STEPS = 0,
+	RENDER_PASS_DEBUG_SAMPLES = 1,
+	RENDER_PASS_DEBUG_VARIANCE = 2,
+	RENDER_PASS_DEBUG_IMPORTANCE = 3,
 };
 
 /* a renderlayer is a full image, but with all passes and samples */
diff --git a/source/blender/render/intern/source/render_result.c b/source/blender/render/intern/source/render_result.c
index 6486844..16343ce 100644
--- a/source/blender/render/intern/source/render_result.c
+++ b/source/blender/render/intern/source/render_result.c
@@ -452,6 +452,12 @@ static const char *debug_pass_type_name_get(int debug_type)
 	switch (debug_type) {
 		case RENDER_PASS_DEBUG_BVH_TRAVERSAL_STEPS:
 			return "BVH Traversal Steps";
+		case RENDER_PASS_DEBUG_SAMPLES:
+			return "Number of samples";
+		case RENDER_PASS_DEBUG_VARIANCE:
+			return "Pixel variance";
+		case RENDER_PASS_DEBUG_IMPORTANCE:
+			return "Pixel importance";
 	}
 	return "Unknown";
 }
@@ -614,6 +620,12 @@ RenderResult *render_result_new(Render *re, rcti *partrct, int crop, int savebuf
 		if (BKE_scene_use_new_shading_nodes(re->scene)) {
 			render_layer_add_debug_pass(rr, rl, 1, SCE_PASS_DEBUG,
 			        RENDER_PASS_DEBUG_BVH_TRAVERSAL_STEPS);
+			render_layer_add_debug_pass(rr, rl, 1, SCE_PASS_DEBUG,
+			        RENDER_PASS_DEBUG_SAMPLES);
+			render_layer_add_debug_pass(rr, rl, 4, SCE_PASS_DEBUG,
+			        RENDER_PASS_DEBUG_VARIANCE);
+			render_layer_add_debug_pass(rr, rl, 1, SCE_PASS_DEBUG,
+			        RENDER_PASS_DEBUG_IMPORTANCE);
 		}
 #endif
 	}
 
